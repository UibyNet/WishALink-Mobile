/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ActivityApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    list(userId: number | undefined): Observable<ActivityListModel[]> {
        let url_ = this.baseUrl + "/api/activity/list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ActivityListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ActivityEditModel | undefined): Observable<ActivityListModel> {
        let url_ = this.baseUrl + "/api/activity/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ActivityListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ActivityEditModel | undefined): Observable<ActivityListModel> {
        let url_ = this.baseUrl + "/api/activity/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ActivityListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListModel>(<any>null);
    }

    /**
     * @param activityId (optional) 
     * @return Success
     */
    delete(activityId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/activity/delete?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AppsettingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    list(): Observable<Setting[]> {
        let url_ = this.baseUrl + "/api/appsetting/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<Setting[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Setting[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Setting[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Setting.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Setting[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Setting[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/appsetting/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuthApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: UserModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verify(body: VerifyModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgot(body: ForgotModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgot(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processForgot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CategoryApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    list(userId: number | undefined): Observable<CategoryListModel[]> {
        let url_ = this.baseUrl + "/api/category/list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<CategoryListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<CategoryListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param order (optional) 
     * @param isHidden (optional) 
     * @param media (optional) 
     * @return Success
     */
    create(id: number | undefined, name: string | undefined, order: number | undefined, isHidden: boolean | undefined, media: FileParameter | undefined): Observable<CategoryListModel> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (order === null || order === undefined)
            throw new Error("The parameter 'order' cannot be null.");
        else
            content_.append("Order", order.toString());
        if (isHidden === null || isHidden === undefined)
            throw new Error("The parameter 'isHidden' cannot be null.");
        else
            content_.append("IsHidden", isHidden.toString());
        if (media === null || media === undefined)
            throw new Error("The parameter 'media' cannot be null.");
        else
            content_.append("Media", media.data, media.fileName ? media.fileName : "Media");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryListModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param order (optional) 
     * @param isHidden (optional) 
     * @param media (optional) 
     * @return Success
     */
    update(id: number | undefined, name: string | undefined, order: number | undefined, isHidden: boolean | undefined, media: FileParameter | undefined): Observable<CategoryListModel> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (order === null || order === undefined)
            throw new Error("The parameter 'order' cannot be null.");
        else
            content_.append("Order", order.toString());
        if (isHidden === null || isHidden === undefined)
            throw new Error("The parameter 'isHidden' cannot be null.");
        else
            content_.append("IsHidden", isHidden.toString());
        if (media === null || media === undefined)
            throw new Error("The parameter 'media' cannot be null.");
        else
            content_.append("Media", media.data, media.fileName ? media.fileName : "Media");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryListModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListModel>(<any>null);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    delete(categoryId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/category/delete?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    upload(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/common/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadmedia(file: FileParameter | undefined): Observable<Media> {
        let url_ = this.baseUrl + "/api/common/uploadmedia";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadmedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadmedia(<any>response_);
                } catch (e) {
                    return <Observable<Media>><any>_observableThrow(e);
                }
            } else
                return <Observable<Media>><any>_observableThrow(response_);
        }));
    }

    protected processUploadmedia(response: HttpResponseBase): Observable<Media> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Media.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Media>(<any>null);
    }

    /**
     * @param fileNames (optional) 
     * @return Success
     */
    uploadremove(fileNames: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/common/uploadremove?";
        if (fileNames === null)
            throw new Error("The parameter 'fileNames' cannot be null.");
        else if (fileNames !== undefined)
            url_ += "fileNames=" + encodeURIComponent("" + fileNames) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadremove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadremove(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadremove(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contact(body: Contact | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/common/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    privacypolicy(): Observable<string> {
        let url_ = this.baseUrl + "/api/common/privacypolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrivacypolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrivacypolicy(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrivacypolicy(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class LocationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param regionId (optional) 
     * @return Success
     */
    countries(regionId: number | undefined): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/location/countries?";
        if (regionId === null)
            throw new Error("The parameter 'regionId' cannot be null.");
        else if (regionId !== undefined)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    provinces(countryId: number | undefined): Observable<Province[]> {
        let url_ = this.baseUrl + "/api/location/provinces?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProvinces(<any>response_);
                } catch (e) {
                    return <Observable<Province[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Province[]>><any>_observableThrow(response_);
        }));
    }

    protected processProvinces(response: HttpResponseBase): Observable<Province[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Province.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Province[]>(<any>null);
    }

    /**
     * @param provinceid (optional) 
     * @return Success
     */
    districts(provinceid: number | undefined): Observable<District[]> {
        let url_ = this.baseUrl + "/api/location/districts?";
        if (provinceid === null)
            throw new Error("The parameter 'provinceid' cannot be null.");
        else if (provinceid !== undefined)
            url_ += "provinceid=" + encodeURIComponent("" + provinceid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDistricts(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processDistricts(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(District.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * @param districtid (optional) 
     * @return Success
     */
    neighborhoods(districtid: number | undefined): Observable<Neighborhood[]> {
        let url_ = this.baseUrl + "/api/location/neighborhoods?";
        if (districtid === null)
            throw new Error("The parameter 'districtid' cannot be null.");
        else if (districtid !== undefined)
            url_ += "districtid=" + encodeURIComponent("" + districtid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNeighborhoods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNeighborhoods(<any>response_);
                } catch (e) {
                    return <Observable<Neighborhood[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Neighborhood[]>><any>_observableThrow(response_);
        }));
    }

    protected processNeighborhoods(response: HttpResponseBase): Observable<Neighborhood[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Neighborhood.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Neighborhood[]>(<any>null);
    }
}

@Injectable()
export class NotificationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    list(): Observable<Notification[]> {
        let url_ = this.baseUrl + "/api/notification/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<Notification[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Notification[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Notification[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Notification.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Notification[]>(<any>null);
    }
}

@Injectable()
export class PostApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    list(userId: number | undefined): Observable<PostListModel[]> {
        let url_ = this.baseUrl + "/api/post/list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PostListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PostListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostListModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: PostEditModel | undefined): Observable<PostListModel> {
        let url_ = this.baseUrl + "/api/post/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PostListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostListModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PostListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostListModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PostEditModel | undefined): Observable<PostListModel> {
        let url_ = this.baseUrl + "/api/post/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PostListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostListModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PostListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostListModel>(<any>null);
    }

    /**
     * @param postId (optional) 
     * @return Success
     */
    delete(postId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/post/delete?";
        if (postId === null)
            throw new Error("The parameter 'postId' cannot be null.");
        else if (postId !== undefined)
            url_ += "postId=" + encodeURIComponent("" + postId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param url (optional) 
     * @return Success
     */
    fetch(url: string | undefined): Observable<MetaInfoModel> {
        let url_ = this.baseUrl + "/api/post/fetch?";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<MetaInfoModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MetaInfoModel>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<MetaInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MetaInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MetaInfoModel>(<any>null);
    }
}

@Injectable()
export class ProfileApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    info(userId: number | undefined): Observable<SocialUserListModel> {
        let url_ = this.baseUrl + "/api/profile/info?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInfo(<any>response_);
                } catch (e) {
                    return <Observable<SocialUserListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocialUserListModel>><any>_observableThrow(response_);
        }));
    }

    protected processInfo(response: HttpResponseBase): Observable<SocialUserListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SocialUserListModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocialUserListModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param currentPassword (optional) 
     * @param newPassword (optional) 
     * @return Success
     */
    changepassword(currentPassword: string | undefined, newPassword: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/profile/changepassword?";
        if (currentPassword === null)
            throw new Error("The parameter 'currentPassword' cannot be null.");
        else if (currentPassword !== undefined)
            url_ += "currentPassword=" + encodeURIComponent("" + currentPassword) + "&";
        if (newPassword === null)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangepassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangepassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangepassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    changeprofilepicture(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/profile/changeprofilepicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeprofilepicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeprofilepicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processChangeprofilepicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    removeprofilepicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/profile/removeprofilepicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveprofilepicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveprofilepicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveprofilepicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SocialApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    follow(userId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/social/follow?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFollow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollow(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processFollow(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    unfollow(userId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/social/unfollow?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnfollow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnfollow(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUnfollow(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    followings(userId: number | undefined): Observable<SocialUserListModel[]> {
        let url_ = this.baseUrl + "/api/social/followings?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFollowings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollowings(<any>response_);
                } catch (e) {
                    return <Observable<SocialUserListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocialUserListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processFollowings(response: HttpResponseBase): Observable<SocialUserListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialUserListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocialUserListModel[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    followers(userId: number | undefined): Observable<SocialUserListModel[]> {
        let url_ = this.baseUrl + "/api/social/followers?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFollowers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollowers(<any>response_);
                } catch (e) {
                    return <Observable<SocialUserListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocialUserListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processFollowers(response: HttpResponseBase): Observable<SocialUserListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialUserListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocialUserListModel[]>(<any>null);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    searchusers(value: string | undefined): Observable<SocialUserListModel[]> {
        let url_ = this.baseUrl + "/api/social/searchusers?";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchusers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchusers(<any>response_);
                } catch (e) {
                    return <Observable<SocialUserListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SocialUserListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchusers(response: HttpResponseBase): Observable<SocialUserListModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SocialUserListModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocialUserListModel[]>(<any>null);
    }
}

export class ActivityEditModel implements IActivityEditModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    startDate?: string | undefined;
    endDate?: string | undefined;
    hasReminder?: boolean;
    isHidden?: boolean;

    constructor(data?: IActivityEditModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.startDate = _data["StartDate"];
            this.endDate = _data["EndDate"];
            this.hasReminder = _data["HasReminder"];
            this.isHidden = _data["IsHidden"];
        }
    }

    static fromJS(data: any): ActivityEditModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityEditModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["StartDate"] = this.startDate;
        data["EndDate"] = this.endDate;
        data["HasReminder"] = this.hasReminder;
        data["IsHidden"] = this.isHidden;
        return data; 
    }
}

export interface IActivityEditModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    startDate?: string | undefined;
    endDate?: string | undefined;
    hasReminder?: boolean;
    isHidden?: boolean;
}

export class ActivityListModel implements IActivityListModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    hasReminder?: boolean;
    isHidden?: boolean;
    startDate?: string | undefined;
    endDate?: string | undefined;

    constructor(data?: IActivityListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.hasReminder = _data["HasReminder"];
            this.isHidden = _data["IsHidden"];
            this.startDate = _data["StartDate"];
            this.endDate = _data["EndDate"];
        }
    }

    static fromJS(data: any): ActivityListModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["HasReminder"] = this.hasReminder;
        data["IsHidden"] = this.isHidden;
        data["StartDate"] = this.startDate;
        data["EndDate"] = this.endDate;
        return data; 
    }
}

export interface IActivityListModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    hasReminder?: boolean;
    isHidden?: boolean;
    startDate?: string | undefined;
    endDate?: string | undefined;
}

export class Address implements IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export class CategoryListModel implements ICategoryListModel {
    id?: number;
    name?: string | undefined;
    order?: number;
    isPredefined?: boolean;
    isHidden?: boolean;
    mediaUrl?: string | undefined;
    postCount?: number;

    constructor(data?: ICategoryListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.order = _data["Order"];
            this.isPredefined = _data["IsPredefined"];
            this.isHidden = _data["IsHidden"];
            this.mediaUrl = _data["MediaUrl"];
            this.postCount = _data["PostCount"];
        }
    }

    static fromJS(data: any): CategoryListModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Order"] = this.order;
        data["IsPredefined"] = this.isPredefined;
        data["IsHidden"] = this.isHidden;
        data["MediaUrl"] = this.mediaUrl;
        data["PostCount"] = this.postCount;
        return data; 
    }
}

export interface ICategoryListModel {
    id?: number;
    name?: string | undefined;
    order?: number;
    isPredefined?: boolean;
    isHidden?: boolean;
    mediaUrl?: string | undefined;
    postCount?: number;
}

export class Contact implements IContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    message?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.phoneNumber = _data["PhoneNumber"];
            this.email = _data["Email"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["PhoneNumber"] = this.phoneNumber;
        data["Email"] = this.email;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    message?: string | undefined;
}

export class Country implements ICountry {
    id?: number;
    iso2!: string;
    iso3!: string;
    name!: string;
    nationality?: string | undefined;
    regionId?: number;
    region?: Region;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.iso2 = _data["Iso2"];
            this.iso3 = _data["Iso3"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
            this.regionId = _data["RegionId"];
            this.region = _data["Region"] ? Region.fromJS(_data["Region"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Iso2"] = this.iso2;
        data["Iso3"] = this.iso3;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        data["RegionId"] = this.regionId;
        data["Region"] = this.region ? this.region.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICountry {
    id?: number;
    iso2: string;
    iso3: string;
    name: string;
    nationality?: string | undefined;
    regionId?: number;
    region?: Region;
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name!: string;
    type?: string | undefined;
    location?: string | undefined;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.location = _data["Location"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Location"] = this.location;
        return data; 
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name: string;
    type?: string | undefined;
    location?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.key = _data["Key"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Key"] = this.key;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;
}

export class ForgotModel implements IForgotModel {
    phoneNumber?: string | undefined;

    constructor(data?: IForgotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): ForgotModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IForgotModel {
    phoneNumber?: string | undefined;
}

export class Group implements IGroup {
    id?: number;
    name!: string;
    description?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IGroup {
    id?: number;
    name: string;
    description?: string | undefined;
    isDeleted?: boolean;
}

export class LoginModel implements ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        return data; 
    }
}

export interface ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;
}

export class Media implements IMedia {
    id?: number;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;
    isDeleted?: boolean;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.caption = _data["Caption"];
            this.fileSize = _data["FileSize"];
            this.fileName = _data["FileName"];
            this.mediaType = _data["MediaType"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Caption"] = this.caption;
        data["FileSize"] = this.fileSize;
        data["FileName"] = this.fileName;
        data["MediaType"] = this.mediaType;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IMedia {
    id?: number;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;
    isDeleted?: boolean;
}

export enum MediaType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class MetaInfoModel implements IMetaInfoModel {
    hasData?: boolean;
    url?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    keywords?: string | undefined;
    mediaUrl?: string | undefined;
    mediaId?: number;

    constructor(data?: IMetaInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasData = _data["HasData"];
            this.url = _data["Url"];
            this.title = _data["Title"];
            this.description = _data["Description"];
            this.keywords = _data["Keywords"];
            this.mediaUrl = _data["MediaUrl"];
            this.mediaId = _data["MediaId"];
        }
    }

    static fromJS(data: any): MetaInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new MetaInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasData"] = this.hasData;
        data["Url"] = this.url;
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["Keywords"] = this.keywords;
        data["MediaUrl"] = this.mediaUrl;
        data["MediaId"] = this.mediaId;
        return data; 
    }
}

export interface IMetaInfoModel {
    hasData?: boolean;
    url?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    keywords?: string | undefined;
    mediaUrl?: string | undefined;
    mediaId?: number;
}

export class Neighborhood implements INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: INeighborhood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.name = _data["Name"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): Neighborhood {
        data = typeof data === 'object' ? data : {};
        let result = new Neighborhood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ZipCode"] = this.zipCode;
        return data; 
    }
}

export interface INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;
}

export class Notification implements INotification {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: Group;
    userId?: number | undefined;
    user?: User;
    sendDate?: moment.Moment;
    type?: NotificationType;
    isSent?: boolean;
    isRead?: boolean;
    isDeleted?: boolean;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.body = _data["Body"];
            this.data = _data["Data"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.sendDate = _data["SendDate"] ? moment(_data["SendDate"].toString()) : <any>undefined;
            this.type = _data["Type"];
            this.isSent = _data["IsSent"];
            this.isRead = _data["IsRead"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["Body"] = this.body;
        data["Data"] = this.data;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["Type"] = this.type;
        data["IsSent"] = this.isSent;
        data["IsRead"] = this.isRead;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface INotification {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: Group;
    userId?: number | undefined;
    user?: User;
    sendDate?: moment.Moment;
    type?: NotificationType;
    isSent?: boolean;
    isRead?: boolean;
    isDeleted?: boolean;
}

export enum NotificationType {
    _1 = 1,
    _2 = 2,
}

export class PostEditModel implements IPostEditModel {
    id?: number;
    mediaId?: number | undefined;
    activityId?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;
    brand?: string | undefined;
    model?: string | undefined;
    color?: string | undefined;
    size?: string | undefined;
    description?: string | undefined;
    tags?: string | undefined;

    constructor(data?: IPostEditModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.mediaId = _data["MediaId"];
            this.activityId = _data["ActivityId"];
            this.name = _data["Name"];
            this.url = _data["Url"];
            this.brand = _data["Brand"];
            this.model = _data["Model"];
            this.color = _data["Color"];
            this.size = _data["Size"];
            this.description = _data["Description"];
            this.tags = _data["Tags"];
        }
    }

    static fromJS(data: any): PostEditModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostEditModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["MediaId"] = this.mediaId;
        data["ActivityId"] = this.activityId;
        data["Name"] = this.name;
        data["Url"] = this.url;
        data["Brand"] = this.brand;
        data["Model"] = this.model;
        data["Color"] = this.color;
        data["Size"] = this.size;
        data["Description"] = this.description;
        data["Tags"] = this.tags;
        return data; 
    }
}

export interface IPostEditModel {
    id?: number;
    mediaId?: number | undefined;
    activityId?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;
    brand?: string | undefined;
    model?: string | undefined;
    color?: string | undefined;
    size?: string | undefined;
    description?: string | undefined;
    tags?: string | undefined;
}

export class PostListModel implements IPostListModel {
    id?: number;
    name?: string | undefined;
    url?: string | undefined;
    brand?: string | undefined;
    model?: string | undefined;
    color?: string | undefined;
    size?: string | undefined;
    description?: string | undefined;
    keywords?: string | undefined;
    mediaUrl?: string | undefined;
    activity?: ActivityListModel;

    constructor(data?: IPostListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.url = _data["Url"];
            this.brand = _data["Brand"];
            this.model = _data["Model"];
            this.color = _data["Color"];
            this.size = _data["Size"];
            this.description = _data["Description"];
            this.keywords = _data["Keywords"];
            this.mediaUrl = _data["MediaUrl"];
            this.activity = _data["Activity"] ? ActivityListModel.fromJS(_data["Activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostListModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Url"] = this.url;
        data["Brand"] = this.brand;
        data["Model"] = this.model;
        data["Color"] = this.color;
        data["Size"] = this.size;
        data["Description"] = this.description;
        data["Keywords"] = this.keywords;
        data["MediaUrl"] = this.mediaUrl;
        data["Activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPostListModel {
    id?: number;
    name?: string | undefined;
    url?: string | undefined;
    brand?: string | undefined;
    model?: string | undefined;
    color?: string | undefined;
    size?: string | undefined;
    description?: string | undefined;
    keywords?: string | undefined;
    mediaUrl?: string | undefined;
    activity?: ActivityListModel;
}

export class Province implements IProvince {
    id?: number;
    countryId!: number;
    country?: Country;
    name!: string;
    type?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        return data; 
    }
}

export interface IProvince {
    id?: number;
    countryId: number;
    country?: Country;
    name: string;
    type?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class Region implements IRegion {
    id?: number;
    name!: string;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IRegion {
    id?: number;
    name: string;
}

export class Role implements IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;
}

export class Setting implements ISetting {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data; 
    }
}

export interface ISetting {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class SocialUserListModel implements ISocialUserListModel {
    id?: number;
    fullName?: string | undefined;
    profilePictureUrl?: string | undefined;
    isFollowing?: boolean;
    followersCount?: number;
    followingsCount?: number;
    notificationCount?: number;

    constructor(data?: ISocialUserListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.fullName = _data["FullName"];
            this.profilePictureUrl = _data["ProfilePictureUrl"];
            this.isFollowing = _data["IsFollowing"];
            this.followersCount = _data["FollowersCount"];
            this.followingsCount = _data["FollowingsCount"];
            this.notificationCount = _data["NotificationCount"];
        }
    }

    static fromJS(data: any): SocialUserListModel {
        data = typeof data === 'object' ? data : {};
        let result = new SocialUserListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["FullName"] = this.fullName;
        data["ProfilePictureUrl"] = this.profilePictureUrl;
        data["IsFollowing"] = this.isFollowing;
        data["FollowersCount"] = this.followersCount;
        data["FollowingsCount"] = this.followingsCount;
        data["NotificationCount"] = this.notificationCount;
        return data; 
    }
}

export interface ISocialUserListModel {
    id?: number;
    fullName?: string | undefined;
    profilePictureUrl?: string | undefined;
    isFollowing?: boolean;
    followersCount?: number;
    followingsCount?: number;
    notificationCount?: number;
}

export class TokenModel implements ITokenModel {
    isNeedVerify?: boolean;
    token?: string | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNeedVerify = _data["IsNeedVerify"];
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsNeedVerify"] = this.isNeedVerify;
        data["Token"] = this.token;
        return data; 
    }
}

export interface ITokenModel {
    isNeedVerify?: boolean;
    token?: string | undefined;
}

export class User implements IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string | undefined;
    version?: number;
    isActive?: boolean;
    isDeleted?: boolean;
    groupId?: number | undefined;
    group?: Group;
    firstName?: string | undefined;
    normalizedFirstName?: string | undefined;
    lastName?: string | undefined;
    normalizedLastName?: string | undefined;
    normalizedFullName?: string | undefined;
    notes?: string | undefined;
    fcmToken?: string | undefined;
    otp?: string | undefined;
    address?: string | undefined;
    profilePicture?: Media;
    profilePictureId?: number | undefined;
    addresses?: UserAddress[] | undefined;
    roles?: UserRole[] | undefined;
    followings?: UserFollow[] | undefined;
    followers?: UserFollow[] | undefined;
    blockedUsers?: UserBlock[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.userGuid = _data["UserGuid"];
            this.version = _data["Version"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            this.firstName = _data["FirstName"];
            this.normalizedFirstName = _data["NormalizedFirstName"];
            this.lastName = _data["LastName"];
            this.normalizedLastName = _data["NormalizedLastName"];
            this.normalizedFullName = _data["NormalizedFullName"];
            this.notes = _data["Notes"];
            this.fcmToken = _data["FcmToken"];
            this.otp = _data["Otp"];
            this.address = _data["Address"];
            this.profilePicture = _data["ProfilePicture"] ? Media.fromJS(_data["ProfilePicture"]) : <any>undefined;
            this.profilePictureId = _data["ProfilePictureId"];
            if (Array.isArray(_data["Addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["Addresses"])
                    this.addresses!.push(UserAddress.fromJS(item));
            }
            if (Array.isArray(_data["Roles"])) {
                this.roles = [] as any;
                for (let item of _data["Roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["Followings"])) {
                this.followings = [] as any;
                for (let item of _data["Followings"])
                    this.followings!.push(UserFollow.fromJS(item));
            }
            if (Array.isArray(_data["Followers"])) {
                this.followers = [] as any;
                for (let item of _data["Followers"])
                    this.followers!.push(UserFollow.fromJS(item));
            }
            if (Array.isArray(_data["BlockedUsers"])) {
                this.blockedUsers = [] as any;
                for (let item of _data["BlockedUsers"])
                    this.blockedUsers!.push(UserBlock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["UserGuid"] = this.userGuid;
        data["Version"] = this.version;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["FirstName"] = this.firstName;
        data["NormalizedFirstName"] = this.normalizedFirstName;
        data["LastName"] = this.lastName;
        data["NormalizedLastName"] = this.normalizedLastName;
        data["NormalizedFullName"] = this.normalizedFullName;
        data["Notes"] = this.notes;
        data["FcmToken"] = this.fcmToken;
        data["Otp"] = this.otp;
        data["Address"] = this.address;
        data["ProfilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        data["ProfilePictureId"] = this.profilePictureId;
        if (Array.isArray(this.addresses)) {
            data["Addresses"] = [];
            for (let item of this.addresses)
                data["Addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item.toJSON());
        }
        if (Array.isArray(this.followings)) {
            data["Followings"] = [];
            for (let item of this.followings)
                data["Followings"].push(item.toJSON());
        }
        if (Array.isArray(this.followers)) {
            data["Followers"] = [];
            for (let item of this.followers)
                data["Followers"].push(item.toJSON());
        }
        if (Array.isArray(this.blockedUsers)) {
            data["BlockedUsers"] = [];
            for (let item of this.blockedUsers)
                data["BlockedUsers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string | undefined;
    version?: number;
    isActive?: boolean;
    isDeleted?: boolean;
    groupId?: number | undefined;
    group?: Group;
    firstName?: string | undefined;
    normalizedFirstName?: string | undefined;
    lastName?: string | undefined;
    normalizedLastName?: string | undefined;
    normalizedFullName?: string | undefined;
    notes?: string | undefined;
    fcmToken?: string | undefined;
    otp?: string | undefined;
    address?: string | undefined;
    profilePicture?: Media;
    profilePictureId?: number | undefined;
    addresses?: UserAddress[] | undefined;
    roles?: UserRole[] | undefined;
    followings?: UserFollow[] | undefined;
    followers?: UserFollow[] | undefined;
    blockedUsers?: UserBlock[] | undefined;
}

export class UserAddress implements IUserAddress {
    id?: number;
    userId?: number;
    user?: User;
    addressId?: number;
    address?: Address;
    isPrimary?: boolean;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.addressId = _data["AddressId"];
            this.address = _data["Address"] ? Address.fromJS(_data["Address"]) : <any>undefined;
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["AddressId"] = this.addressId;
        data["Address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["IsPrimary"] = this.isPrimary;
        return data; 
    }
}

export interface IUserAddress {
    id?: number;
    userId?: number;
    user?: User;
    addressId?: number;
    address?: Address;
    isPrimary?: boolean;
}

export class UserBlock implements IUserBlock {
    id?: number;
    sourceUser?: User;
    sourceUserId?: number;
    blockedUser?: User;
    blockedUserId?: number;

    constructor(data?: IUserBlock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.sourceUser = _data["SourceUser"] ? User.fromJS(_data["SourceUser"]) : <any>undefined;
            this.sourceUserId = _data["SourceUserId"];
            this.blockedUser = _data["BlockedUser"] ? User.fromJS(_data["BlockedUser"]) : <any>undefined;
            this.blockedUserId = _data["BlockedUserId"];
        }
    }

    static fromJS(data: any): UserBlock {
        data = typeof data === 'object' ? data : {};
        let result = new UserBlock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["SourceUser"] = this.sourceUser ? this.sourceUser.toJSON() : <any>undefined;
        data["SourceUserId"] = this.sourceUserId;
        data["BlockedUser"] = this.blockedUser ? this.blockedUser.toJSON() : <any>undefined;
        data["BlockedUserId"] = this.blockedUserId;
        return data; 
    }
}

export interface IUserBlock {
    id?: number;
    sourceUser?: User;
    sourceUserId?: number;
    blockedUser?: User;
    blockedUserId?: number;
}

export class UserFollow implements IUserFollow {
    id?: number;
    sourceUser?: User;
    sourceUserId?: number;
    followedUser?: User;
    followedUserId?: number;

    constructor(data?: IUserFollow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.sourceUser = _data["SourceUser"] ? User.fromJS(_data["SourceUser"]) : <any>undefined;
            this.sourceUserId = _data["SourceUserId"];
            this.followedUser = _data["FollowedUser"] ? User.fromJS(_data["FollowedUser"]) : <any>undefined;
            this.followedUserId = _data["FollowedUserId"];
        }
    }

    static fromJS(data: any): UserFollow {
        data = typeof data === 'object' ? data : {};
        let result = new UserFollow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["SourceUser"] = this.sourceUser ? this.sourceUser.toJSON() : <any>undefined;
        data["SourceUserId"] = this.sourceUserId;
        data["FollowedUser"] = this.followedUser ? this.followedUser.toJSON() : <any>undefined;
        data["FollowedUserId"] = this.followedUserId;
        return data; 
    }
}

export interface IUserFollow {
    id?: number;
    sourceUser?: User;
    sourceUserId?: number;
    followedUser?: User;
    followedUserId?: number;
}

export class UserModel implements IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fcmToken?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.fcmToken = _data["FcmToken"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["FcmToken"] = this.fcmToken;
        return data; 
    }
}

export interface IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fcmToken?: string | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;
}

export class VerifyModel implements IVerifyModel {
    otp!: string;
    phoneNumber!: string;

    constructor(data?: IVerifyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otp = _data["Otp"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): VerifyModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Otp"] = this.otp;
        data["PhoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifyModel {
    otp: string;
    phoneNumber: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = getFileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
export function getFileReader(): FileReader {
	const fileReader = new FileReader();
	const zoneOriginalInstance = (fileReader as any)["__zone_symbol__originalInstance"];
	return zoneOriginalInstance || fileReader;
}