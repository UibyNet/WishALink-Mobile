/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppsettingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    list(): Observable<Setting[]> {
        let url_ = this.baseUrl + "/api/appsetting/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<Setting[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Setting[]>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<Setting[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Setting.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Setting[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Setting[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/appsetting/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key];
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuthApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: UserModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verify(body: VerifyModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgot(body: ForgotModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgot(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processForgot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    upload(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/common/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadmedia(file: FileParameter | undefined): Observable<Media> {
        let url_ = this.baseUrl + "/api/common/uploadmedia";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadmedia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadmedia(<any>response_);
                } catch (e) {
                    return <Observable<Media>><any>_observableThrow(e);
                }
            } else
                return <Observable<Media>><any>_observableThrow(response_);
        }));
    }

    protected processUploadmedia(response: HttpResponseBase): Observable<Media> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Media.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Media>(<any>null);
    }

    /**
     * @param fileNames (optional) 
     * @return Success
     */
    uploadremove(fileNames: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/common/uploadremove?";
        if (fileNames === null)
            throw new Error("The parameter 'fileNames' cannot be null.");
        else if (fileNames !== undefined)
            url_ += "fileNames=" + encodeURIComponent("" + fileNames) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadremove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadremove(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadremove(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contact(body: Contact | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/common/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    privacypolicy(): Observable<string> {
        let url_ = this.baseUrl + "/api/common/privacypolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrivacypolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrivacypolicy(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPrivacypolicy(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class LocationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param regionId (optional) 
     * @return Success
     */
    countries(regionId: number | undefined): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/location/countries?";
        if (regionId === null)
            throw new Error("The parameter 'regionId' cannot be null.");
        else if (regionId !== undefined)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }

    /**
     * @param countryId (optional) 
     * @return Success
     */
    provinces(countryId: string | undefined): Observable<Province[]> {
        let url_ = this.baseUrl + "/api/location/provinces?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProvinces(<any>response_);
                } catch (e) {
                    return <Observable<Province[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Province[]>><any>_observableThrow(response_);
        }));
    }

    protected processProvinces(response: HttpResponseBase): Observable<Province[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Province.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Province[]>(<any>null);
    }

    /**
     * @param provinceid (optional) 
     * @return Success
     */
    districts(provinceid: number | undefined): Observable<District[]> {
        let url_ = this.baseUrl + "/api/location/districts?";
        if (provinceid === null)
            throw new Error("The parameter 'provinceid' cannot be null.");
        else if (provinceid !== undefined)
            url_ += "provinceid=" + encodeURIComponent("" + provinceid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDistricts(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processDistricts(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(District.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    /**
     * @param districtid (optional) 
     * @return Success
     */
    neighborhoods(districtid: number | undefined): Observable<Neighborhood[]> {
        let url_ = this.baseUrl + "/api/location/neighborhoods?";
        if (districtid === null)
            throw new Error("The parameter 'districtid' cannot be null.");
        else if (districtid !== undefined)
            url_ += "districtid=" + encodeURIComponent("" + districtid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNeighborhoods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNeighborhoods(<any>response_);
                } catch (e) {
                    return <Observable<Neighborhood[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Neighborhood[]>><any>_observableThrow(response_);
        }));
    }

    protected processNeighborhoods(response: HttpResponseBase): Observable<Neighborhood[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Neighborhood.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Neighborhood[]>(<any>null);
    }
}

@Injectable()
export class ProfileApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    info(): Observable<User> {
        let url_ = this.baseUrl + "/api/profile/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInfo(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processInfo(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/profile/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param currentPassword (optional) 
     * @param newPassword (optional) 
     * @return Success
     */
    changepassword(currentPassword: string | undefined, newPassword: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/profile/changepassword?";
        if (currentPassword === null)
            throw new Error("The parameter 'currentPassword' cannot be null.");
        else if (currentPassword !== undefined)
            url_ += "currentPassword=" + encodeURIComponent("" + currentPassword) + "&";
        if (newPassword === null)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangepassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangepassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangepassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class Contact implements IContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    message?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.phoneNumber = _data["PhoneNumber"];
            this.email = _data["Email"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["PhoneNumber"] = this.phoneNumber;
        data["Email"] = this.email;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    message?: string | undefined;
}

export class Country implements ICountry {
    id?: string | undefined;
    code!: string;
    name!: string;
    nationality?: string | undefined;
    regionId?: number;
    region?: Region;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
            this.regionId = _data["RegionId"];
            this.region = _data["Region"] ? Region.fromJS(_data["Region"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        data["RegionId"] = this.regionId;
        data["Region"] = this.region ? this.region.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICountry {
    id?: string | undefined;
    code: string;
    name: string;
    nationality?: string | undefined;
    regionId?: number;
    region?: Region;
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name!: string;
    type?: string | undefined;
    location?: string | undefined;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.location = _data["Location"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Location"] = this.location;
        return data; 
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name: string;
    type?: string | undefined;
    location?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.key = _data["Key"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Key"] = this.key;
        data["Message"] = this.message;
        return data; 
    }
}

export interface IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;
}

export class ForgotModel implements IForgotModel {
    phoneNumber?: string | undefined;

    constructor(data?: IForgotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): ForgotModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IForgotModel {
    phoneNumber?: string | undefined;
}

export class Group implements IGroup {
    id?: number;
    name!: string;
    description?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IGroup {
    id?: number;
    name: string;
    description?: string | undefined;
    isDeleted?: boolean;
}

export class LoginModel implements ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        return data; 
    }
}

export interface ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;
}

export class Media implements IMedia {
    id?: number;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;
    isDeleted?: boolean;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.caption = _data["Caption"];
            this.fileSize = _data["FileSize"];
            this.fileName = _data["FileName"];
            this.mediaType = _data["MediaType"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Caption"] = this.caption;
        data["FileSize"] = this.fileSize;
        data["FileName"] = this.fileName;
        data["MediaType"] = this.mediaType;
        data["IsDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IMedia {
    id?: number;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;
    isDeleted?: boolean;
}

export enum MediaType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Neighborhood implements INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: INeighborhood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.name = _data["Name"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): Neighborhood {
        data = typeof data === 'object' ? data : {};
        let result = new Neighborhood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ZipCode"] = this.zipCode;
        return data; 
    }
}

export interface INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;
}

export class Province implements IProvince {
    id?: number;
    countryId!: string;
    country?: Country;
    name!: string;
    type?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        return data; 
    }
}

export interface IProvince {
    id?: number;
    countryId: string;
    country?: Country;
    name: string;
    type?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
}

export class Region implements IRegion {
    id?: number;
    name!: string;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IRegion {
    id?: number;
    name: string;
}

export class Role implements IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;
}

export class Setting implements ISetting {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data; 
    }
}

export interface ISetting {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class TokenModel implements ITokenModel {
    isNeedVerify?: boolean;
    token?: string | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isNeedVerify = _data["IsNeedVerify"];
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsNeedVerify"] = this.isNeedVerify;
        data["Token"] = this.token;
        return data; 
    }
}

export interface ITokenModel {
    isNeedVerify?: boolean;
    token?: string | undefined;
}

export class User implements IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string | undefined;
    version?: number;
    isActive?: boolean;
    isDeleted?: boolean;
    groupId?: number | undefined;
    group?: Group;
    firstName?: string | undefined;
    lastName?: string | undefined;
    notes?: string | undefined;
    fcmToken?: string | undefined;
    otp?: string | undefined;
    address?: string | undefined;
    userMedias?: UserMedia[] | undefined;
    roles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.userGuid = _data["UserGuid"];
            this.version = _data["Version"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.notes = _data["Notes"];
            this.fcmToken = _data["FcmToken"];
            this.otp = _data["Otp"];
            this.address = _data["Address"];
            if (Array.isArray(_data["UserMedias"])) {
                this.userMedias = [] as any;
                for (let item of _data["UserMedias"])
                    this.userMedias!.push(UserMedia.fromJS(item));
            }
            if (Array.isArray(_data["Roles"])) {
                this.roles = [] as any;
                for (let item of _data["Roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["UserGuid"] = this.userGuid;
        data["Version"] = this.version;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Notes"] = this.notes;
        data["FcmToken"] = this.fcmToken;
        data["Otp"] = this.otp;
        data["Address"] = this.address;
        if (Array.isArray(this.userMedias)) {
            data["UserMedias"] = [];
            for (let item of this.userMedias)
                data["UserMedias"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string | undefined;
    version?: number;
    isActive?: boolean;
    isDeleted?: boolean;
    groupId?: number | undefined;
    group?: Group;
    firstName?: string | undefined;
    lastName?: string | undefined;
    notes?: string | undefined;
    fcmToken?: string | undefined;
    otp?: string | undefined;
    address?: string | undefined;
    userMedias?: UserMedia[] | undefined;
    roles?: UserRole[] | undefined;
}

export class UserMedia implements IUserMedia {
    id?: number;
    userId?: number;
    mediaId?: number;
    media?: Media;

    constructor(data?: IUserMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserMedia {
        data = typeof data === 'object' ? data : {};
        let result = new UserMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserMedia {
    id?: number;
    userId?: number;
    mediaId?: number;
    media?: Media;
}

export class UserModel implements IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fcmToken?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.fcmToken = _data["FcmToken"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["FcmToken"] = this.fcmToken;
        return data; 
    }
}

export interface IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fcmToken?: string | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;
}

export class VerifyModel implements IVerifyModel {
    otp!: string;
    phoneNumber!: string;

    constructor(data?: IVerifyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otp = _data["Otp"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): VerifyModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Otp"] = this.otp;
        data["PhoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifyModel {
    otp: string;
    phoneNumber: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}