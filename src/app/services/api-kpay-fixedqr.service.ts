/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const KPAY_FIXEDQR_API_URL = new InjectionToken<string>('KPAY_FIXEDQR_API_URL');

@Injectable()
export class ApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(KPAY_FIXEDQR_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.kpay.com.tr/FixedQR/V1";
    }

    /**
     * Checks service access and returns server date time
     * @return Ok (Service is running and accessible)
     */
    ping(): Observable<PingResultDTO> {
        let url_ = this.baseUrl + "/Ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(<any>response_);
                } catch (e) {
                    return <Observable<PingResultDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PingResultDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<PingResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PingResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PingResultDTO>(<any>null);
    }

    /**
     * Returns a list of API Result codes and descriptions
     * @return Operation completed successfully
     */
    getAPIResultList(): Observable<APIResult[]> {
        let url_ = this.baseUrl + "/APIResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAPIResultList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPIResultList(<any>response_);
                } catch (e) {
                    return <Observable<APIResult[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<APIResult[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPIResultList(response: HttpResponseBase): Observable<APIResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(APIResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<APIResult[]>(<any>null);
    }

    /**
     * Creates a payment request for a checkout marked with CheckoutCode
     * @param body Information about the payment request
     * @return The payment request has been created successfully
     */
    createPaymentRequest(body: PaymentRequestDTO): Observable<PaymentSummaryDTO> {
        let url_ = this.baseUrl + "/PaymentRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentRequest(<any>response_);
                } catch (e) {
                    return <Observable<PaymentSummaryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentSummaryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaymentRequest(response: HttpResponseBase): Observable<PaymentSummaryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PaymentSummaryDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 502) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result502: any = null;
            let resultData502 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result502 = APIResultDTO.fromJS(resultData502);
            return throwException("Bad Gateway", status, _responseText, _headers, result502);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentSummaryDTO>(<any>null);
    }

    /**
     * Returns the status of a given payment request by it's KPayTxnID
     * @param kPayTxnID KPay transaction ID (GUID) (e.g. 88091384-7d85-47a1-97eb-6573d706eedc)
     * @return OK (The request has succeeded)
     */
    getPaymentStatus(kPayTxnID: string): Observable<PaymentStatusEnum | null> {
        let url_ = this.baseUrl + "/PaymentRequest/{KPayTxnID}/Status";
        if (kPayTxnID === undefined || kPayTxnID === null)
            throw new Error("The parameter 'kPayTxnID' must be defined.");
        url_ = url_.replace("{KPayTxnID}", encodeURIComponent("" + kPayTxnID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentStatus(<any>response_);
                } catch (e) {
                    return <Observable<PaymentStatusEnum | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentStatusEnum | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentStatus(response: HttpResponseBase): Observable<PaymentStatusEnum | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentStatusEnum | null>(<any>null);
    }

    /**
     * Returns information about a given payment request by it's KPayTxnID
     * @param kPayTxnID KPay transaction ID (GUID) (e.g. 88091384-7d85-47a1-97eb-6573d706eedc)
     * @return OK (The request has succeeded)
     */
    getPaymentInfo(kPayTxnID: string): Observable<PaymentSummaryDTO> {
        let url_ = this.baseUrl + "/PaymentRequest/{KPayTxnID}";
        if (kPayTxnID === undefined || kPayTxnID === null)
            throw new Error("The parameter 'kPayTxnID' must be defined.");
        url_ = url_.replace("{KPayTxnID}", encodeURIComponent("" + kPayTxnID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentSummaryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentSummaryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentSummaryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentSummaryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentSummaryDTO>(<any>null);
    }

    /**
     * Cancels a payment request if it isn't paid yet by it's KPayTxnID
     * @param kPayTxnID KPay transaction ID (GUID) (e.g. 88091384-7d85-47a1-97eb-6573d706eedc)
     * @return OK (The payment request is cancelled)
     */
    cancelRequest(kPayTxnID: string): Observable<void> {
        let url_ = this.baseUrl + "/PaymentRequest/{KPayTxnID}";
        if (kPayTxnID === undefined || kPayTxnID === null)
            throw new Error("The parameter 'kPayTxnID' must be defined.");
        url_ = url_.replace("{KPayTxnID}", encodeURIComponent("" + kPayTxnID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

/** Information about the payment request */
export class PaymentRequestDTO implements IPaymentRequestDTO {
    checkoutCode!: string;
    /** The requested payment amount (Use at most 2 decimal digits) */
    transactionAmountTRY!: number;
    /** The unique transaction ID the merchant system has assigned to this payment */
    merchantTransactionID!: string;
    requesterMemberID?: string;
    /** The VAT amount of the purchase (Use at most 2 decimal digits) */
    vATAmountTRY?: number | undefined;
    /** Campaign info/code (if any) */
    campaignInfo?: string;
    /** The receipt number the merchant system has assigned to this payment */
    merchantReceiptNo?: string;
    /** The ID of the customer in the merchant system */
    customerID?: string;
    /** Name of the customer in the merchant system */
    customerFirstName?: string;
    /** Surname of the customer in the merchant system */
    customerLastName?: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    readonly customerGSMNo?: string;
    /** Email address of the customer in the merchant system */
    customerEmail?: string;
    /** Note/description for the payment */
    paymentNote?: string;
    /** The lines of the receipt this payment is for in the merchant system */
    paymentRequestLines?: PaymentRequestLineDTO[];

    constructor(data?: IPaymentRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkoutCode = _data["CheckoutCode"];
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.merchantTransactionID = _data["MerchantTransactionID"];
            this.requesterMemberID = _data["RequesterMemberID"];
            this.vATAmountTRY = _data["VATAmountTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.merchantReceiptNo = _data["MerchantReceiptNo"];
            this.customerID = _data["CustomerID"];
            this.customerFirstName = _data["CustomerFirstName"];
            this.customerLastName = _data["CustomerLastName"];
            (<any>this).customerGSMNo = _data["CustomerGSMNo"];
            this.customerEmail = _data["CustomerEmail"];
            this.paymentNote = _data["PaymentNote"];
            if (Array.isArray(_data["PaymentRequestLines"])) {
                this.paymentRequestLines = [] as any;
                for (let item of _data["PaymentRequestLines"])
                    this.paymentRequestLines!.push(PaymentRequestLineDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CheckoutCode"] = this.checkoutCode;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["MerchantTransactionID"] = this.merchantTransactionID;
        data["RequesterMemberID"] = this.requesterMemberID;
        data["VATAmountTRY"] = this.vATAmountTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["MerchantReceiptNo"] = this.merchantReceiptNo;
        data["CustomerID"] = this.customerID;
        data["CustomerFirstName"] = this.customerFirstName;
        data["CustomerLastName"] = this.customerLastName;
        data["CustomerGSMNo"] = this.customerGSMNo;
        data["CustomerEmail"] = this.customerEmail;
        data["PaymentNote"] = this.paymentNote;
        if (Array.isArray(this.paymentRequestLines)) {
            data["PaymentRequestLines"] = [];
            for (let item of this.paymentRequestLines)
                data["PaymentRequestLines"].push(item.toJSON());
        }
        return data; 
    }
}

/** Information about the payment request */
export interface IPaymentRequestDTO {
    checkoutCode: string;
    /** The requested payment amount (Use at most 2 decimal digits) */
    transactionAmountTRY: number;
    /** The unique transaction ID the merchant system has assigned to this payment */
    merchantTransactionID: string;
    requesterMemberID?: string;
    /** The VAT amount of the purchase (Use at most 2 decimal digits) */
    vATAmountTRY?: number | undefined;
    /** Campaign info/code (if any) */
    campaignInfo?: string;
    /** The receipt number the merchant system has assigned to this payment */
    merchantReceiptNo?: string;
    /** The ID of the customer in the merchant system */
    customerID?: string;
    /** Name of the customer in the merchant system */
    customerFirstName?: string;
    /** Surname of the customer in the merchant system */
    customerLastName?: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    customerGSMNo?: string;
    /** Email address of the customer in the merchant system */
    customerEmail?: string;
    /** Note/description for the payment */
    paymentNote?: string;
    /** The lines of the receipt this payment is for in the merchant system */
    paymentRequestLines?: PaymentRequestLineDTO[];
}

/** Information for one line of the receipt this payment is for */
export class PaymentRequestLineDTO implements IPaymentRequestLineDTO {
    /** Product name */
    productName!: string;
    /** Quantity (Use at most 4 decimal digits) */
    quantity!: number;
    /** Product unit name */
    unitName!: string;
    /** Line amount (Use at most 2 decimal digits) */
    lineTotalTRY!: number;
    /** Product code */
    productCode?: string;
    /** Promotion code */
    promotionCode?: string;
    /** Line amount (Use at most 2 decimal digits) */
    unitPriceTRY?: number | undefined;
    /** Integer VAT Rate in percent */
    vATRate?: number | undefined;
    /** VAT Amount of the line (Use at most 2 decimal digits) */
    vATAmountTRY?: number | undefined;

    constructor(data?: IPaymentRequestLineDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["ProductName"];
            this.quantity = _data["Quantity"];
            this.unitName = _data["UnitName"];
            this.lineTotalTRY = _data["LineTotalTRY"];
            this.productCode = _data["ProductCode"];
            this.promotionCode = _data["PromotionCode"];
            this.unitPriceTRY = _data["UnitPriceTRY"];
            this.vATRate = _data["VATRate"];
            this.vATAmountTRY = _data["VATAmountTRY"];
        }
    }

    static fromJS(data: any): PaymentRequestLineDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestLineDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProductName"] = this.productName;
        data["Quantity"] = this.quantity;
        data["UnitName"] = this.unitName;
        data["LineTotalTRY"] = this.lineTotalTRY;
        data["ProductCode"] = this.productCode;
        data["PromotionCode"] = this.promotionCode;
        data["UnitPriceTRY"] = this.unitPriceTRY;
        data["VATRate"] = this.vATRate;
        data["VATAmountTRY"] = this.vATAmountTRY;
        return data; 
    }
}

/** Information for one line of the receipt this payment is for */
export interface IPaymentRequestLineDTO {
    /** Product name */
    productName: string;
    /** Quantity (Use at most 4 decimal digits) */
    quantity: number;
    /** Product unit name */
    unitName: string;
    /** Line amount (Use at most 2 decimal digits) */
    lineTotalTRY: number;
    /** Product code */
    productCode?: string;
    /** Promotion code */
    promotionCode?: string;
    /** Line amount (Use at most 2 decimal digits) */
    unitPriceTRY?: number | undefined;
    /** Integer VAT Rate in percent */
    vATRate?: number | undefined;
    /** VAT Amount of the line (Use at most 2 decimal digits) */
    vATAmountTRY?: number | undefined;
}

/** Type of the payment */
export enum PaymentTypeEnum {
    Request = "Request",
    DynamicQRBEX = "DynamicQRBEX",
    FixedQRBEX = "FixedQRBEX",
    CreditCard = "CreditCard",
    Cash = "Cash",
    ECRCash = "ECRCash",
    ECRCreditCard = "ECRCreditCard",
    ECRBEX = "ECRBEX",
    ECROther = "ECROther",
    StoredCreditCard = "StoredCreditCard",
    MasterPass = "MasterPass",
}

/** Default status is 'Started' after the transaction is created. Await until a status other than 'None' or 'Started' is returned. - None : Initial request state - Started : Transaction is created (Created) - Paid : Transaction is processed successfully (Success) - Denied : Payment is denied (Failure) - Orphaned : Transaction is orphaned (Failure) - Timeout : Transaction is timed out (Failure) - Cancelled : Transaction is cancelled by the merchant (Cancellation) - AutoCancelled : Transaction is cancelled by the system (Cancellation) - Refunded : Payment amount is refunded to the customer (Refunded) - Closed : Transaction is processed successfully (Success) */
export enum PaymentStatusEnum {
    None = "None",
    Started = "Started",
    Paid = "Paid",
    Denied = "Denied",
    Orphaned = "Orphaned",
    Timeout = "Timeout",
    Cancelled = "Cancelled",
    AutoCancelled = "AutoCancelled",
    Refunded = "Refunded",
    Closed = "Closed",
}

/** Payment summary information */
export class PaymentSummaryDTO implements IPaymentSummaryDTO {
    kPayTxnID!: string;
    paymentType!: PaymentTypeEnum | undefined;
    paymentStatus!: PaymentStatusEnum | undefined;
    requestTimeStamp!: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    /** The requested payment amount */
    transactionAmountTRY!: number | undefined;
    /** The amount paid by the customer */
    paymentAmountTRY!: number | undefined;
    /** Discount amount (if any) (TransactionAmountTRY - PaymentAmountTRY) */
    discountAmountTRY!: number | undefined;
    /** Campaign name causing the discount (if any) */
    campaignInfo?: string;
    /** Institution name */
    institutionName?: string;
    /** Institution branch name */
    branchName?: string;
    /** An error occurred during the processing */
    hasError?: boolean | undefined;
    /** Description of the error (if any) */
    errorDescription?: string;
    /** Description of the payment result if unsuccessful */
    paymentResult?: string;

    constructor(data?: IPaymentSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kPayTxnID = _data["KPayTxnID"];
            this.paymentType = _data["PaymentType"];
            this.paymentStatus = _data["PaymentStatus"];
            this.requestTimeStamp = _data["RequestTimeStamp"] ? moment(_data["RequestTimeStamp"].toString()) : <any>undefined;
            this.paymentTimeStamp = _data["PaymentTimeStamp"] ? moment(_data["PaymentTimeStamp"].toString()) : <any>undefined;
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.paymentAmountTRY = _data["PaymentAmountTRY"];
            this.discountAmountTRY = _data["DiscountAmountTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.institutionName = _data["InstitutionName"];
            this.branchName = _data["BranchName"];
            this.hasError = _data["HasError"];
            this.errorDescription = _data["ErrorDescription"];
            this.paymentResult = _data["PaymentResult"];
        }
    }

    static fromJS(data: any): PaymentSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["KPayTxnID"] = this.kPayTxnID;
        data["PaymentType"] = this.paymentType;
        data["PaymentStatus"] = this.paymentStatus;
        data["RequestTimeStamp"] = this.requestTimeStamp ? this.requestTimeStamp.toISOString() : <any>undefined;
        data["PaymentTimeStamp"] = this.paymentTimeStamp ? this.paymentTimeStamp.toISOString() : <any>undefined;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["PaymentAmountTRY"] = this.paymentAmountTRY;
        data["DiscountAmountTRY"] = this.discountAmountTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["InstitutionName"] = this.institutionName;
        data["BranchName"] = this.branchName;
        data["HasError"] = this.hasError;
        data["ErrorDescription"] = this.errorDescription;
        data["PaymentResult"] = this.paymentResult;
        return data; 
    }
}

/** Payment summary information */
export interface IPaymentSummaryDTO {
    kPayTxnID: string;
    paymentType: PaymentTypeEnum | undefined;
    paymentStatus: PaymentStatusEnum | undefined;
    requestTimeStamp: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    /** The requested payment amount */
    transactionAmountTRY: number | undefined;
    /** The amount paid by the customer */
    paymentAmountTRY: number | undefined;
    /** Discount amount (if any) (TransactionAmountTRY - PaymentAmountTRY) */
    discountAmountTRY: number | undefined;
    /** Campaign name causing the discount (if any) */
    campaignInfo?: string;
    /** Institution name */
    institutionName?: string;
    /** Institution branch name */
    branchName?: string;
    /** An error occurred during the processing */
    hasError?: boolean | undefined;
    /** Description of the error (if any) */
    errorDescription?: string;
    /** Description of the payment result if unsuccessful */
    paymentResult?: string;
}

/** Result of the API operation */
export class APIResult implements IAPIResult {
    /** An integer code indicating the result of the operation */
    code!: number;
    /** A description of the result code */
    message!: string;

    constructor(data?: IAPIResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): APIResult {
        data = typeof data === 'object' ? data : {};
        let result = new APIResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Message"] = this.message;
        return data; 
    }
}

/** Result of the API operation */
export interface IAPIResult {
    /** An integer code indicating the result of the operation */
    code: number;
    /** A description of the result code */
    message: string;
}

/** Result of the API operation */
export class APIResultDTO implements IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code!: number;
    /** A description of the result code */
    message!: string;
    /** Error list (if any) */
    errors?: string[];

    constructor(data?: IAPIResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): APIResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new APIResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item);
        }
        return data; 
    }
}

/** Result of the API operation */
export interface IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code: number;
    /** A description of the result code */
    message: string;
    /** Error list (if any) */
    errors?: string[];
}

/** Ping result */
export class PingResultDTO implements IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime!: moment.Moment;

    constructor(data?: IPingResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverDateTime = _data["ServerDateTime"] ? moment(_data["ServerDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PingResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PingResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ServerDateTime"] = this.serverDateTime ? this.serverDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** Ping result */
export interface IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime: moment.Moment;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = getFileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
export function getFileReader(): FileReader {
	const fileReader = new FileReader();
	const zoneOriginalInstance = (fileReader as any)["__zone_symbol__originalInstance"];
	return zoneOriginalInstance || fileReader;
}