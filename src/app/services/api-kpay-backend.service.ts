/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const KPAY_BACKEND_API_URL = new InjectionToken<string>('KPAY_BACKEND_API_URL');

@Injectable()
export class ApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(KPAY_BACKEND_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.kpay.com.tr/AppBackend/V1";
    }

    /**
     * Checks service access and returns server date time
     * @return Ok (Service is running and accessible)
     */
    ping(): Observable<PingResultDTO> {
        let url_ = this.baseUrl + "/Ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(<any>response_);
                } catch (e) {
                    return <Observable<PingResultDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PingResultDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<PingResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PingResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PingResultDTO>(<any>null);
    }

    /**
     * Returns a list of API Result codes and descriptions
     * @return Operation completed successfully
     */
    getAPIResultList(): Observable<APIResultDTO[]> {
        let url_ = this.baseUrl + "/APIResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAPIResultList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPIResultList(<any>response_);
                } catch (e) {
                    return <Observable<APIResultDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<APIResultDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPIResultList(response: HttpResponseBase): Observable<APIResultDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(APIResultDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<APIResultDTO[]>(<any>null);
    }

    /**
     * Creates a member
     * @param body Information about the member
     * @return The member created successfully
     */
    createMember(body: MemberCreateDTO): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDTO>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MemberDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(<any>null);
    }

    /**
     * Gets member information
     * @param gSMNo GSM No of the member (CCCCCAAATTTTTTT, e.g. 905331234567)
     * @return The member found
     */
    getMember(gSMNo: string): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member/{GSMNo}";
        if (gSMNo === undefined || gSMNo === null)
            throw new Error("The parameter 'gSMNo' must be defined.");
        url_ = url_.replace("{GSMNo}", encodeURIComponent("" + gSMNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(<any>null);
    }

    /**
     * Deletes a member
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @return The member deleted successfully
     */
    deleteMember(memberID: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{MemberID}";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMember(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMember(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Updates a member
     * @param body Information about the member
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @return The member updated successfully
     */
    updateMember(body: MemberDTO, memberID: string): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member/{MemberID}";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<MemberDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberDTO>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(<any>null);
    }

    /**
     * Checks if the password is correct
     * @param gSMNo GSM No of the member (CCCCCAAATTTTTTT, e.g. 905331234567)
     * @param password Password to be checked
     * @return Password is correct
     */
    checkPassword(gSMNo: string, password: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{GSMNo}/CheckPassword?";
        if (gSMNo === undefined || gSMNo === null)
            throw new Error("The parameter 'gSMNo' must be defined.");
        url_ = url_.replace("{GSMNo}", encodeURIComponent("" + gSMNo));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Creates a new password (NNNNNN, e.g. 256349) and sends it to the member via an SMS
     * @param gSMNo GSM No of the member (CCCCCAAATTTTTTT, e.g. 905331234567)
     * @return Password is created and sent
     */
    resetPassword(gSMNo: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{GSMNo}/ResetPassword";
        if (gSMNo === undefined || gSMNo === null)
            throw new Error("The parameter 'gSMNo' must be defined.");
        url_ = url_.replace("{GSMNo}", encodeURIComponent("" + gSMNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Creates an OTP (NNNNNN, e.g. 514269) and sends it to the member via an SMS
     * @param gSMNo GSM No of the member (CCCCCAAATTTTTTT, e.g. 905331234567)
     * @return OTP is sent
     */
    sendOTP(gSMNo: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{GSMNo}/SendOTP";
        if (gSMNo === undefined || gSMNo === null)
            throw new Error("The parameter 'gSMNo' must be defined.");
        url_ = url_.replace("{GSMNo}", encodeURIComponent("" + gSMNo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Checks if the OTP is correct and not timed out (3 mins)
     * @param gSMNo GSM No of the member (CCCCCAAATTTTTTT, e.g. 905331234567)
     * @param oTP OTP to be checked
     * @return OTP is correct
     */
    checkOTP(gSMNo: string, oTP: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{GSMNo}/CheckOTP?";
        if (gSMNo === undefined || gSMNo === null)
            throw new Error("The parameter 'gSMNo' must be defined.");
        url_ = url_.replace("{GSMNo}", encodeURIComponent("" + gSMNo));
        if (oTP === undefined || oTP === null)
            throw new Error("The parameter 'oTP' must be defined and cannot be null.");
        else
            url_ += "OTP=" + encodeURIComponent("" + oTP) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOTP(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Stores a card for the member
     * @param body Information about the card
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @return The card stored successfully
     */
    addCard(body: CardCreateDTO, memberID: string): Observable<CardDTO> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Card";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCard(<any>response_);
                } catch (e) {
                    return <Observable<CardDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDTO>><any>_observableThrow(response_);
        }));
    }

    protected processAddCard(response: HttpResponseBase): Observable<CardDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CardDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO>(<any>null);
    }

    /**
     * Gets member's stored cards
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @return List of stored cards
     */
    getCardList(memberID: string): Observable<CardDTO[]> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Card";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardList(<any>response_);
                } catch (e) {
                    return <Observable<CardDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardList(response: HttpResponseBase): Observable<CardDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO[]>(<any>null);
    }

    /**
     * Gets information for a specific card
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @param cardID System given ID of the card (GUID) (e.g. 257d20e0-4d9a-4b53-8b73-3aa40115364e)
     * @return Card information
     */
    getCard(memberID: string, cardID: string): Observable<CardDTO> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Card/{CardID}";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        if (cardID === undefined || cardID === null)
            throw new Error("The parameter 'cardID' must be defined.");
        url_ = url_.replace("{CardID}", encodeURIComponent("" + cardID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCard(<any>response_);
                } catch (e) {
                    return <Observable<CardDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetCard(response: HttpResponseBase): Observable<CardDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO>(<any>null);
    }

    /**
     * Deletes a card
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @param cardID System given ID of the card (GUID) (e.g. 257d20e0-4d9a-4b53-8b73-3aa40115364e)
     * @return The card deleted successfully
     */
    deleteCard(memberID: string, cardID: string): Observable<void> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Card/{CardID}";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        if (cardID === undefined || cardID === null)
            throw new Error("The parameter 'cardID' must be defined.");
        url_ = url_.replace("{CardID}", encodeURIComponent("" + cardID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCard(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Returns a paginated list of member's payments ordered by date time
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @param pageNumber The requested page number
     * @param pageSize The requested page size
     * @param sortOrder (optional) Date time sort order, A : Ascending D : Descending (If empty, D will be used)
     * @param beginTimeStamp (optional) Inclusive begin time stamp for query in ISO 8601 format (e.g."2018-08-20T22:29:56.3526165+03:00") (If emtpy, time of day beginning of today will be used)
     * @param endTimeStamp (optional) Inclusive end time stamp for query in ISO 8601 format (e.g."2018-08-20T22:29:56.3526165+03:00") (If emtpy, time of day will be used)
     * @return List of payments
     */
    getPaginatedPaymentSummary(memberID: string, pageNumber: number, pageSize: number, sortOrder: string | undefined, beginTimeStamp: moment.Moment | undefined, endTimeStamp: moment.Moment | undefined): Observable<PaginatedPaymentSummaryDTO> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Payment?";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (beginTimeStamp === null)
            throw new Error("The parameter 'beginTimeStamp' cannot be null.");
        else if (beginTimeStamp !== undefined)
            url_ += "BeginTimeStamp=" + encodeURIComponent(beginTimeStamp ? "" + beginTimeStamp.toJSON() : "") + "&";
        if (endTimeStamp === null)
            throw new Error("The parameter 'endTimeStamp' cannot be null.");
        else if (endTimeStamp !== undefined)
            url_ += "EndTimeStamp=" + encodeURIComponent(endTimeStamp ? "" + endTimeStamp.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedPaymentSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedPaymentSummary(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedPaymentSummaryDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedPaymentSummaryDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaginatedPaymentSummary(response: HttpResponseBase): Observable<PaginatedPaymentSummaryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedPaymentSummaryDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedPaymentSummaryDTO>(<any>null);
    }

    /**
     * Returns details of a payment
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @param kPayTxnID KPay transaction ID (GUID) (e.g. 88091384-7d85-47a1-97eb-6573d706eedc)
     * @return OK (The request has succeeded)
     */
    getPayment(memberID: string, kPayTxnID: string): Observable<PaymentDTO> {
        let url_ = this.baseUrl + "/Member/{MemberID}/Payment/{KPayTxnID}";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        if (kPayTxnID === undefined || kPayTxnID === null)
            throw new Error("The parameter 'kPayTxnID' must be defined.");
        url_ = url_.replace("{KPayTxnID}", encodeURIComponent("" + kPayTxnID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<PaymentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<PaymentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentDTO>(<any>null);
    }

    /**
     * Returns application info
     * @return OK (The request has succeeded)
     */
    getApplicationInfo(): Observable<ApplicationInfoDTO> {
        let url_ = this.baseUrl + "/Application/Info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationInfo(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationInfoDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationInfoDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationInfo(response: HttpResponseBase): Observable<ApplicationInfoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationInfoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationInfoDTO>(<any>null);
    }

    /**
     * Returns an application visual by it's code
     * @return OK (The request has succeeded)
     */
    getApplicationVisual(code: string, dataVersion: number): Observable<ApplicationVisualDTO> {
        let url_ = this.baseUrl + "/Application/Visual/{Code}?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{Code}", encodeURIComponent("" + code));
        if (dataVersion === undefined || dataVersion === null)
            throw new Error("The parameter 'dataVersion' must be defined and cannot be null.");
        else
            url_ += "DataVersion=" + encodeURIComponent("" + dataVersion) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationVisual(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationVisualDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationVisualDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationVisual(response: HttpResponseBase): Observable<ApplicationVisualDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationVisualDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationVisualDTO>(<any>null);
    }

    /**
     * Returns list of provinces which has establishments in them
     * @return OK (The request has succeeded)
     */
    getProvinces(): Observable<ProvinceDTO[]> {
        let url_ = this.baseUrl + "/Application/Province";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinces(<any>response_);
                } catch (e) {
                    return <Observable<ProvinceDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProvinceDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProvinces(response: HttpResponseBase): Observable<ProvinceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDTO[]>(<any>null);
    }

    /**
     * Returns the end user agreement in the selected language
     * @param language Language for the retrieved text
     * @return OK (The request has succeeded)
     */
    getEndUserAgreement(language: Language): Observable<string> {
        let url_ = this.baseUrl + "/Application/EndUserAgreement?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEndUserAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEndUserAgreement(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetEndUserAgreement(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Returns the personal data agreement in the selected language
     * @param language Language for the retrieved text
     * @return OK (The request has succeeded)
     */
    getPersonalDataAgreement(language: Language): Observable<string> {
        let url_ = this.baseUrl + "/Application/PersonalDataAgreement?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonalDataAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonalDataAgreement(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonalDataAgreement(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Returns the card storage agreement in the selected language
     * @param language Language for the retrieved text
     * @return OK (The request has succeeded)
     */
    getCardStorageAgreement(language: Language): Observable<string> {
        let url_ = this.baseUrl + "/Application/CardStorageAgreement?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardStorageAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardStorageAgreement(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardStorageAgreement(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Returns application presentation in the selected language
     * @param language Language for the retrieved text
     * @return OK (The request has succeeded)
     */
    getPresentation(language: Language): Observable<string> {
        let url_ = this.baseUrl + "/Application/Presentation?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPresentation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPresentation(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPresentation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Creates a member complaint
     * @param body Information about the comlaint
     * @return The complaint created successfully
     */
    createComplaint(body: ComplaintDTO): Observable<void> {
        let url_ = this.baseUrl + "/Application/Complaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComplaint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComplaint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Returns the list of the establishments with summary data
     * @param language Language for the retrieved text
     * @return OK (The request has succeeded)
     */
    getEstablishmentSummaryList(language: Language): Observable<EstablishmentSummaryDTO[]> {
        let url_ = this.baseUrl + "/Application/EstablishmentSummary?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstablishmentSummaryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstablishmentSummaryList(<any>response_);
                } catch (e) {
                    return <Observable<EstablishmentSummaryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstablishmentSummaryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstablishmentSummaryList(response: HttpResponseBase): Observable<EstablishmentSummaryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstablishmentSummaryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstablishmentSummaryDTO[]>(<any>null);
    }

    /**
     * Returns the list of the establishments with full data
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getEstablishmentList(language: Language, includeVisual: boolean | undefined): Observable<EstablishmentDTO[]> {
        let url_ = this.baseUrl + "/Application/Establishment?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstablishmentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstablishmentList(<any>response_);
                } catch (e) {
                    return <Observable<EstablishmentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstablishmentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstablishmentList(response: HttpResponseBase): Observable<EstablishmentDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstablishmentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstablishmentDTO[]>(<any>null);
    }

    /**
     * Returns the establishment's data
     * @param rID Unique integer ID for an entity
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getEstablishment(rID: number, language: Language, includeVisual: boolean | undefined): Observable<EstablishmentDTO> {
        let url_ = this.baseUrl + "/Application/Establishment/{RID}?";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstablishment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstablishment(<any>response_);
                } catch (e) {
                    return <Observable<EstablishmentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstablishmentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstablishment(response: HttpResponseBase): Observable<EstablishmentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EstablishmentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstablishmentDTO>(<any>null);
    }

    /**
     * Returns the visual of the establishment
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getEstablishmentVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/Establishment/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstablishmentVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstablishmentVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstablishmentVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns the list of the news in the selected language
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getNewsList(language: Language, includeVisual: boolean | undefined): Observable<NewsDTO[]> {
        let url_ = this.baseUrl + "/Application/News?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewsList(<any>response_);
                } catch (e) {
                    return <Observable<NewsDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NewsDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewsList(response: HttpResponseBase): Observable<NewsDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewsDTO[]>(<any>null);
    }

    /**
     * Returns the visual of the news item
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getNewsVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/News/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewsVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewsVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewsVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns a paginated list of events ordered by date time
     * @param language Language for the retrieved text
     * @param pageNumber The requested page number
     * @param pageSize The requested page size
     * @param establishmentRID (optional) Filters the events by the establishment's RID
     * @param eventHeader (optional) Filters events by the header (in the requested language)
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @param sortOrder (optional) Date time sort order, A : Ascending D : Descending (If empty, A will be used)
     * @param beginTimeStamp (optional) Inclusive begin time stamp for query in ISO 8601 format (e.g."2018-08-20T22:29:56.3526165+03:00") (If emtpy, beginning of today will be used)
     * @param endTimeStamp (optional) Inclusive end time stamp for query in ISO 8601 format (e.g."2018-08-20T22:29:56.3526165+03:00") (If emtpy, 3 months would be added to today and used)
     * @return List of events
     */
    getPaginatedEvent(language: Language, pageNumber: number, pageSize: number, establishmentRID: number | undefined, eventHeader: string | undefined, includeVisual: boolean | undefined, sortOrder: string | undefined, beginTimeStamp: moment.Moment | undefined, endTimeStamp: moment.Moment | undefined): Observable<PaginatedEventDTO> {
        let url_ = this.baseUrl + "/Application/Event?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (establishmentRID === null)
            throw new Error("The parameter 'establishmentRID' cannot be null.");
        else if (establishmentRID !== undefined)
            url_ += "EstablishmentRID=" + encodeURIComponent("" + establishmentRID) + "&";
        if (eventHeader === null)
            throw new Error("The parameter 'eventHeader' cannot be null.");
        else if (eventHeader !== undefined)
            url_ += "EventHeader=" + encodeURIComponent("" + eventHeader) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (beginTimeStamp === null)
            throw new Error("The parameter 'beginTimeStamp' cannot be null.");
        else if (beginTimeStamp !== undefined)
            url_ += "BeginTimeStamp=" + encodeURIComponent(beginTimeStamp ? "" + beginTimeStamp.toJSON() : "") + "&";
        if (endTimeStamp === null)
            throw new Error("The parameter 'endTimeStamp' cannot be null.");
        else if (endTimeStamp !== undefined)
            url_ += "EndTimeStamp=" + encodeURIComponent(endTimeStamp ? "" + endTimeStamp.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedEvent(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedEventDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedEventDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaginatedEvent(response: HttpResponseBase): Observable<PaginatedEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedEventDTO>(<any>null);
    }

    /**
     * Returns the event's data
     * @param rID Unique integer ID for an entity
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getEvent(rID: number, language: Language, includeVisual: boolean | undefined): Observable<EventDTO> {
        let url_ = this.baseUrl + "/Application/Event/{RID}?";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvent(<any>response_);
                } catch (e) {
                    return <Observable<EventDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvent(response: HttpResponseBase): Observable<EventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDTO>(<any>null);
    }

    /**
     * Returns the visual of the event
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getEventVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/Event/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns the list of the campaigns in the selected language
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getCampaignList(language: Language, includeVisual: boolean | undefined): Observable<CampaignDTO[]> {
        let url_ = this.baseUrl + "/Application/Campaign?";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignList(<any>response_);
                } catch (e) {
                    return <Observable<CampaignDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CampaignDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignList(response: HttpResponseBase): Observable<CampaignDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CampaignDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CampaignDTO[]>(<any>null);
    }

    /**
     * Returns the visual of the campaign item
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getCampaignVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/Campaign/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampaignVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampaignVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCampaignVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns the list of the Advertisements in the selected language
     * @param memberID System given ID of the member (GUID) (e.g. 5be4947b-0e90-4e2a-b0e8-0242807404d6)
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getAdvertisementList(memberID: string, language: Language, includeVisual: boolean | undefined): Observable<AdvertisementDTO[]> {
        let url_ = this.baseUrl + "/Application/Advertisement/{MemberID}?";
        if (memberID === undefined || memberID === null)
            throw new Error("The parameter 'memberID' must be defined.");
        url_ = url_.replace("{MemberID}", encodeURIComponent("" + memberID));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementList(<any>response_);
                } catch (e) {
                    return <Observable<AdvertisementDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdvertisementDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementList(response: HttpResponseBase): Observable<AdvertisementDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdvertisementDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdvertisementDTO[]>(<any>null);
    }

    /**
     * Returns the visual of the Advertisement
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getAdvertisementVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/Advertisement/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdvertisementVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdvertisementVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdvertisementVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns the list of the Product Categories in the selected language
     * @param establishmentRID Unique integer ID for an Establishment
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @return OK (The request has succeeded)
     */
    getProductCategoryList(establishmentRID: number, language: Language, includeVisual: boolean | undefined): Observable<ProductCategoryDTO[]> {
        let url_ = this.baseUrl + "/Application/ProductCategory?";
        if (establishmentRID === undefined || establishmentRID === null)
            throw new Error("The parameter 'establishmentRID' must be defined and cannot be null.");
        else
            url_ += "EstablishmentRID=" + encodeURIComponent("" + establishmentRID) + "&";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryList(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategoryList(response: HttpResponseBase): Observable<ProductCategoryDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDTO[]>(<any>null);
    }

    /**
     * Returns the visual of the ProductCategory
     * @param rID Unique integer ID for an entity
     * @return OK (The request has succeeded)
     */
    getProductCategoryVisual(rID: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/ProductCategory/{RID}/Visual";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategoryVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns the list of the Products in a Product Category in the selected language
     * @param rID Unique integer ID for an entity
     * @param establishmentRID Unique integer ID for an Establishment
     * @param language Language for the retrieved text
     * @param includeVisual (optional) Includes the Base64 encoded visual in the response
     * @param visualSize (optional) Size of the visual
     * @return OK (The request has succeeded)
     */
    getProductList(rID: number, establishmentRID: number, language: Language, includeVisual: boolean | undefined, visualSize: VisualSize | undefined): Observable<ProductDTO[]> {
        let url_ = this.baseUrl + "/Application/ProductCategory/{RID}/Product?";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        if (establishmentRID === undefined || establishmentRID === null)
            throw new Error("The parameter 'establishmentRID' must be defined and cannot be null.");
        else
            url_ += "EstablishmentRID=" + encodeURIComponent("" + establishmentRID) + "&";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined and cannot be null.");
        else
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (includeVisual === null)
            throw new Error("The parameter 'includeVisual' cannot be null.");
        else if (includeVisual !== undefined)
            url_ += "IncludeVisual=" + encodeURIComponent("" + includeVisual) + "&";
        if (visualSize === null)
            throw new Error("The parameter 'visualSize' cannot be null.");
        else if (visualSize !== undefined)
            url_ += "VisualSize=" + encodeURIComponent("" + visualSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductList(<any>response_);
                } catch (e) {
                    return <Observable<ProductDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductList(response: HttpResponseBase): Observable<ProductDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDTO[]>(<any>null);
    }

    /**
     * Returns the visual of the Product
     * @param rID Unique integer ID for an entity
     * @param visualSize (optional) Size of the visual
     * @return OK (The request has succeeded)
     */
    getProductVisual(rID: number, visualSize: VisualSize | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/Application/Product/{RID}/Visual?";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        if (visualSize === null)
            throw new Error("The parameter 'visualSize' cannot be null.");
        else if (visualSize !== undefined)
            url_ += "VisualSize=" + encodeURIComponent("" + visualSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "image/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductVisual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductVisual(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductVisual(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Returns list of provinces which has Metropol establishments in them
     * @return OK (The request has succeeded)
     */
    getMProvinces(): Observable<ProvinceDTO[]> {
        let url_ = this.baseUrl + "/Metropol/Province";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMProvinces(<any>response_);
                } catch (e) {
                    return <Observable<ProvinceDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProvinceDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMProvinces(response: HttpResponseBase): Observable<ProvinceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDTO[]>(<any>null);
    }

    /**
     * Returns list of districts for a province which has Metropol establishments in them
     * @param provinceRID Unique integer ID for a Province
     * @return OK (The request has succeeded)
     */
    getMDistricts(provinceRID: number): Observable<DistrictDTO[]> {
        let url_ = this.baseUrl + "/Metropol/Province/{ProvinceRID}/District";
        if (provinceRID === undefined || provinceRID === null)
            throw new Error("The parameter 'provinceRID' must be defined.");
        url_ = url_.replace("{ProvinceRID}", encodeURIComponent("" + provinceRID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMDistricts(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMDistricts(response: HttpResponseBase): Observable<DistrictDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DistrictDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDTO[]>(<any>null);
    }

    /**
     * Returns a paginated list of Metropol branches
     * @param provinceRID Unique integer ID for a Province
     * @param districtRID Unique integer ID for a District
     * @param pageNumber The requested page number
     * @param pageSize The requested page size
     * @return List of payments
     */
    getPaginatedBranchList(provinceRID: number, districtRID: number, pageNumber: number, pageSize: number): Observable<PaginatedBranchListDTO> {
        let url_ = this.baseUrl + "/Metropol/Branch/{ProvinceRID}/{DistrictRID}?";
        if (provinceRID === undefined || provinceRID === null)
            throw new Error("The parameter 'provinceRID' must be defined.");
        url_ = url_.replace("{ProvinceRID}", encodeURIComponent("" + provinceRID));
        if (districtRID === undefined || districtRID === null)
            throw new Error("The parameter 'districtRID' must be defined.");
        url_ = url_.replace("{DistrictRID}", encodeURIComponent("" + districtRID));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedBranchList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedBranchList(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedBranchListDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedBranchListDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaginatedBranchList(response: HttpResponseBase): Observable<PaginatedBranchListDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedBranchListDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedBranchListDTO>(<any>null);
    }

    /**
     * Returns checkout information by code (e.g. "KPAY_QW3243_GR5672_XJK98O_000000")
     * @param checkoutCode Unique code for the checkout (e.g. "KPAY_QW3243_GR5672_XJK98O_000000")
     * @return OK (The request has succeeded)
     */
    getCheckout(checkoutCode: string): Observable<CheckoutDTO> {
        let url_ = this.baseUrl + "/Checkout/{CheckoutCode}";
        if (checkoutCode === undefined || checkoutCode === null)
            throw new Error("The parameter 'checkoutCode' must be defined.");
        url_ = url_.replace("{CheckoutCode}", encodeURIComponent("" + checkoutCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCheckout(<any>response_);
                } catch (e) {
                    return <Observable<CheckoutDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckoutDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetCheckout(response: HttpResponseBase): Observable<CheckoutDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckoutDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckoutDTO>(<any>null);
    }
}

/** Type of the connecting device */
export enum DeviceTypeEnum {
    Unknown = "Unknown",
    AndroidPhone = "AndroidPhone",
    AndroidTablet = "AndroidTablet",
    ApplePhone = "ApplePhone",
    AppleTablet = "AppleTablet",
    PC = "PC",
    Embedded = "Embedded",
}

/** Gender of the member */
export enum GenderEnum {
    Unspecified = "Unspecified",
    Male = "Male",
    Female = "Female",
}

/** Type of the member */
export enum MemberTypeEnum {
    Normal = "Normal",
    KPayGoUser = "KPayGoUser",
    KPayGoSeller = "KPayGoSeller",
}

/** Member information for creation */
export class MemberCreateDTO implements IMemberCreateDTO {
    /** First name of the member */
    firstName!: string;
    /** Last name of the member */
    lastName!: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    gSMNo!: string;
    /** Email address of the member */
    email!: string;
    gender?: GenderEnum | undefined;
    /** Date of birth of the member in ISO 8601 full date format */
    dateOfBirth?: moment.Moment | undefined;
    /** Facebook ID of the member */
    facebookID?: string;
    /** TwitterID of the member */
    twitterID?: string;
    /** LinkedIn ID of the member */
    linkedInID?: string;
    /** Profile picture URL of the member */
    pictureURL?: string;
    /** TCKN of the member */
    tCKN?: string;
    /** Password of the member */
    password?: string;
    /** Free storage for member specific data (preferably in JSON) */
    memberData?: string;
    /** The member has accepted the end user agreement (default is true) */
    hasAcceptedEUA!: boolean | undefined;
    /** The member has accepted the personal data agreement (default is true) */
    hasAcceptedPDA!: boolean | undefined;
    /** The member has accepted the card storage agreement (default is false) */
    hasAcceptedCSA?: boolean | undefined;
    /** The member allows SMS notifications (default is false) */
    allowsSMSNotifications?: boolean | undefined;
    /** The member allows email notifications (default is false) */
    allowsEmailNotifications?: boolean | undefined;
    /** The member allows push notifications (default is false) */
    allowsPushNotifications?: boolean | undefined;
    deviceType!: DeviceTypeEnum | undefined;
    /** Manufacturer of the connecting device (e.g. Samsung, Huawei, Apple) */
    deviceManufacturer!: string;
    /** Model of the connecting device (e.g. SM-N975F (Galaxy Note 10+), iPhone10,1 (for iOS, hardware identifier e.g. iPhone10,1 -> iPhone 8)) */
    deviceModel!: string;
    /** OS Version of the connecting device (e.g. 9.0, 11.0.1) */
    deviceOSVersion!: string;

    constructor(data?: IMemberCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.gSMNo = _data["GSMNo"];
            this.email = _data["Email"];
            this.gender = _data["Gender"];
            this.dateOfBirth = _data["DateOfBirth"] ? moment(_data["DateOfBirth"].toString()) : <any>undefined;
            this.facebookID = _data["FacebookID"];
            this.twitterID = _data["TwitterID"];
            this.linkedInID = _data["LinkedInID"];
            this.pictureURL = _data["PictureURL"];
            this.tCKN = _data["TCKN"];
            this.password = _data["Password"];
            this.memberData = _data["MemberData"];
            this.hasAcceptedEUA = _data["HasAcceptedEUA"];
            this.hasAcceptedPDA = _data["HasAcceptedPDA"];
            this.hasAcceptedCSA = _data["HasAcceptedCSA"];
            this.allowsSMSNotifications = _data["AllowsSMSNotifications"];
            this.allowsEmailNotifications = _data["AllowsEmailNotifications"];
            this.allowsPushNotifications = _data["AllowsPushNotifications"];
            this.deviceType = _data["DeviceType"];
            this.deviceManufacturer = _data["DeviceManufacturer"];
            this.deviceModel = _data["DeviceModel"];
            this.deviceOSVersion = _data["DeviceOSVersion"];
        }
    }

    static fromJS(data: any): MemberCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GSMNo"] = this.gSMNo;
        data["Email"] = this.email;
        data["Gender"] = this.gender;
        data["DateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.format('YYYY-MM-DD') : <any>undefined;
        data["FacebookID"] = this.facebookID;
        data["TwitterID"] = this.twitterID;
        data["LinkedInID"] = this.linkedInID;
        data["PictureURL"] = this.pictureURL;
        data["TCKN"] = this.tCKN;
        data["Password"] = this.password;
        data["MemberData"] = this.memberData;
        data["HasAcceptedEUA"] = this.hasAcceptedEUA;
        data["HasAcceptedPDA"] = this.hasAcceptedPDA;
        data["HasAcceptedCSA"] = this.hasAcceptedCSA;
        data["AllowsSMSNotifications"] = this.allowsSMSNotifications;
        data["AllowsEmailNotifications"] = this.allowsEmailNotifications;
        data["AllowsPushNotifications"] = this.allowsPushNotifications;
        data["DeviceType"] = this.deviceType;
        data["DeviceManufacturer"] = this.deviceManufacturer;
        data["DeviceModel"] = this.deviceModel;
        data["DeviceOSVersion"] = this.deviceOSVersion;
        return data; 
    }
}

/** Member information for creation */
export interface IMemberCreateDTO {
    /** First name of the member */
    firstName: string;
    /** Last name of the member */
    lastName: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    gSMNo: string;
    /** Email address of the member */
    email: string;
    gender?: GenderEnum | undefined;
    /** Date of birth of the member in ISO 8601 full date format */
    dateOfBirth?: moment.Moment | undefined;
    /** Facebook ID of the member */
    facebookID?: string;
    /** TwitterID of the member */
    twitterID?: string;
    /** LinkedIn ID of the member */
    linkedInID?: string;
    /** Profile picture URL of the member */
    pictureURL?: string;
    /** TCKN of the member */
    tCKN?: string;
    /** Password of the member */
    password?: string;
    /** Free storage for member specific data (preferably in JSON) */
    memberData?: string;
    /** The member has accepted the end user agreement (default is true) */
    hasAcceptedEUA: boolean | undefined;
    /** The member has accepted the personal data agreement (default is true) */
    hasAcceptedPDA: boolean | undefined;
    /** The member has accepted the card storage agreement (default is false) */
    hasAcceptedCSA?: boolean | undefined;
    /** The member allows SMS notifications (default is false) */
    allowsSMSNotifications?: boolean | undefined;
    /** The member allows email notifications (default is false) */
    allowsEmailNotifications?: boolean | undefined;
    /** The member allows push notifications (default is false) */
    allowsPushNotifications?: boolean | undefined;
    deviceType: DeviceTypeEnum | undefined;
    /** Manufacturer of the connecting device (e.g. Samsung, Huawei, Apple) */
    deviceManufacturer: string;
    /** Model of the connecting device (e.g. SM-N975F (Galaxy Note 10+), iPhone10,1 (for iOS, hardware identifier e.g. iPhone10,1 -> iPhone 8)) */
    deviceModel: string;
    /** OS Version of the connecting device (e.g. 9.0, 11.0.1) */
    deviceOSVersion: string;
}

/** Member information for retrieval and update */
export class MemberDTO implements IMemberDTO {
    /** A list of fields separated by semicolon to be set to null, therefore emptied. FirstName, LastName, GSMNo, Email, Password fields and any field marked as readonly can not be set to null. */
    fieldsToNull?: string;
    /** First name of the member */
    firstName?: string;
    /** Last name of the member */
    lastName?: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    readonly gSMNo?: string;
    memberID?: string;
    /** True if the password is verified at least once (Changing the password will set this field to false) */
    readonly isVerified?: boolean | undefined;
    /** True if the member is a test user */
    readonly isTester?: boolean | undefined;
    /** Email address of the member */
    email?: string;
    gender?: GenderEnum | undefined;
    memberType?: MemberTypeEnum | undefined;
    /** Unique code for the checkout */
    checkoutCode?: string;
    /** Date of birth of the member in ISO 8601 full date format */
    dateOfBirth?: moment.Moment | undefined;
    /** Facebook ID of the member */
    facebookID?: string;
    /** TwitterID of the member */
    twitterID?: string;
    /** LinkedIn ID of the member */
    linkedInID?: string;
    /** Profile picture URL of the member */
    pictureURL?: string;
    /** TCKN of the member */
    tCKN?: string;
    /** Password of the member */
    password?: string;
    /** Free storage for member specific data (preferably in JSON) */
    memberData?: string;
    /** The member has accepted the end user agreement (default is true) */
    readonly hasAcceptedEUA?: boolean | undefined;
    /** The member has accepted the personal data agreement (default is true) */
    readonly hasAcceptedPDA?: boolean | undefined;
    /** The member has accepted the card storage agreement (default is false) */
    hasAcceptedCSA?: boolean | undefined;
    /** The member allows at least one type of notification */
    readonly allowsNotifications?: boolean | undefined;
    /** The member allows SMS notifications (default is false) */
    allowsSMSNotifications?: boolean | undefined;
    /** The member allows email notifications (default is false) */
    allowsEmailNotifications?: boolean | undefined;
    /** The member allows push notifications (default is false) */
    allowsPushNotifications?: boolean | undefined;
    defaultCard?: string;
    deviceType?: DeviceTypeEnum | undefined;
    /** Manufacturer of the connecting device (e.g. Samsung, Huawei, Apple) */
    deviceManufacturer?: string;
    /** Model of the connecting device (e.g. SM-N975F (Galaxy Note 10+), iPhone10,1 (for iOS, hardware identifier e.g. iPhone10,1 -> iPhone 8)) */
    deviceModel?: string;
    /** OS Version of the connecting device (e.g. 9.0, 11.0.1) */
    deviceOSVersion?: string;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    passwordTimeStamp?: moment.Moment | undefined;
    oTPTimeStamp?: moment.Moment | undefined;
    /** Points amount (if any) */
    pointsTRY?: number | undefined;

    constructor(data?: IMemberDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldsToNull = _data["FieldsToNull"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            (<any>this).gSMNo = _data["GSMNo"];
            this.memberID = _data["MemberID"];
            (<any>this).isVerified = _data["IsVerified"];
            (<any>this).isTester = _data["IsTester"];
            this.email = _data["Email"];
            this.gender = _data["Gender"];
            this.memberType = _data["MemberType"];
            this.checkoutCode = _data["CheckoutCode"];
            this.dateOfBirth = _data["DateOfBirth"] ? moment(_data["DateOfBirth"].toString()) : <any>undefined;
            this.facebookID = _data["FacebookID"];
            this.twitterID = _data["TwitterID"];
            this.linkedInID = _data["LinkedInID"];
            this.pictureURL = _data["PictureURL"];
            this.tCKN = _data["TCKN"];
            this.password = _data["Password"];
            this.memberData = _data["MemberData"];
            (<any>this).hasAcceptedEUA = _data["HasAcceptedEUA"];
            (<any>this).hasAcceptedPDA = _data["HasAcceptedPDA"];
            this.hasAcceptedCSA = _data["HasAcceptedCSA"];
            (<any>this).allowsNotifications = _data["AllowsNotifications"];
            this.allowsSMSNotifications = _data["AllowsSMSNotifications"];
            this.allowsEmailNotifications = _data["AllowsEmailNotifications"];
            this.allowsPushNotifications = _data["AllowsPushNotifications"];
            this.defaultCard = _data["DefaultCard"];
            this.deviceType = _data["DeviceType"];
            this.deviceManufacturer = _data["DeviceManufacturer"];
            this.deviceModel = _data["DeviceModel"];
            this.deviceOSVersion = _data["DeviceOSVersion"];
            this.creationTimeStamp = _data["CreationTimeStamp"] ? moment(_data["CreationTimeStamp"].toString()) : <any>undefined;
            this.modificationTimeStamp = _data["ModificationTimeStamp"] ? moment(_data["ModificationTimeStamp"].toString()) : <any>undefined;
            this.passwordTimeStamp = _data["PasswordTimeStamp"] ? moment(_data["PasswordTimeStamp"].toString()) : <any>undefined;
            this.oTPTimeStamp = _data["OTPTimeStamp"] ? moment(_data["OTPTimeStamp"].toString()) : <any>undefined;
            this.pointsTRY = _data["PointsTRY"];
        }
    }

    static fromJS(data: any): MemberDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FieldsToNull"] = this.fieldsToNull;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GSMNo"] = this.gSMNo;
        data["MemberID"] = this.memberID;
        data["IsVerified"] = this.isVerified;
        data["IsTester"] = this.isTester;
        data["Email"] = this.email;
        data["Gender"] = this.gender;
        data["MemberType"] = this.memberType;
        data["CheckoutCode"] = this.checkoutCode;
        data["DateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.format('YYYY-MM-DD') : <any>undefined;
        data["FacebookID"] = this.facebookID;
        data["TwitterID"] = this.twitterID;
        data["LinkedInID"] = this.linkedInID;
        data["PictureURL"] = this.pictureURL;
        data["TCKN"] = this.tCKN;
        data["Password"] = this.password;
        data["MemberData"] = this.memberData;
        data["HasAcceptedEUA"] = this.hasAcceptedEUA;
        data["HasAcceptedPDA"] = this.hasAcceptedPDA;
        data["HasAcceptedCSA"] = this.hasAcceptedCSA;
        data["AllowsNotifications"] = this.allowsNotifications;
        data["AllowsSMSNotifications"] = this.allowsSMSNotifications;
        data["AllowsEmailNotifications"] = this.allowsEmailNotifications;
        data["AllowsPushNotifications"] = this.allowsPushNotifications;
        data["DefaultCard"] = this.defaultCard;
        data["DeviceType"] = this.deviceType;
        data["DeviceManufacturer"] = this.deviceManufacturer;
        data["DeviceModel"] = this.deviceModel;
        data["DeviceOSVersion"] = this.deviceOSVersion;
        data["CreationTimeStamp"] = this.creationTimeStamp ? this.creationTimeStamp.toISOString() : <any>undefined;
        data["ModificationTimeStamp"] = this.modificationTimeStamp ? this.modificationTimeStamp.toISOString() : <any>undefined;
        data["PasswordTimeStamp"] = this.passwordTimeStamp ? this.passwordTimeStamp.toISOString() : <any>undefined;
        data["OTPTimeStamp"] = this.oTPTimeStamp ? this.oTPTimeStamp.toISOString() : <any>undefined;
        data["PointsTRY"] = this.pointsTRY;
        return data; 
    }
}

/** Member information for retrieval and update */
export interface IMemberDTO {
    /** A list of fields separated by semicolon to be set to null, therefore emptied. FirstName, LastName, GSMNo, Email, Password fields and any field marked as readonly can not be set to null. */
    fieldsToNull?: string;
    /** First name of the member */
    firstName?: string;
    /** Last name of the member */
    lastName?: string;
    /** GSM No of the member (CCCCCAAATTTTTTT) */
    gSMNo?: string;
    memberID?: string;
    /** True if the password is verified at least once (Changing the password will set this field to false) */
    isVerified?: boolean | undefined;
    /** True if the member is a test user */
    isTester?: boolean | undefined;
    /** Email address of the member */
    email?: string;
    gender?: GenderEnum | undefined;
    memberType?: MemberTypeEnum | undefined;
    /** Unique code for the checkout */
    checkoutCode?: string;
    /** Date of birth of the member in ISO 8601 full date format */
    dateOfBirth?: moment.Moment | undefined;
    /** Facebook ID of the member */
    facebookID?: string;
    /** TwitterID of the member */
    twitterID?: string;
    /** LinkedIn ID of the member */
    linkedInID?: string;
    /** Profile picture URL of the member */
    pictureURL?: string;
    /** TCKN of the member */
    tCKN?: string;
    /** Password of the member */
    password?: string;
    /** Free storage for member specific data (preferably in JSON) */
    memberData?: string;
    /** The member has accepted the end user agreement (default is true) */
    hasAcceptedEUA?: boolean | undefined;
    /** The member has accepted the personal data agreement (default is true) */
    hasAcceptedPDA?: boolean | undefined;
    /** The member has accepted the card storage agreement (default is false) */
    hasAcceptedCSA?: boolean | undefined;
    /** The member allows at least one type of notification */
    allowsNotifications?: boolean | undefined;
    /** The member allows SMS notifications (default is false) */
    allowsSMSNotifications?: boolean | undefined;
    /** The member allows email notifications (default is false) */
    allowsEmailNotifications?: boolean | undefined;
    /** The member allows push notifications (default is false) */
    allowsPushNotifications?: boolean | undefined;
    defaultCard?: string;
    deviceType?: DeviceTypeEnum | undefined;
    /** Manufacturer of the connecting device (e.g. Samsung, Huawei, Apple) */
    deviceManufacturer?: string;
    /** Model of the connecting device (e.g. SM-N975F (Galaxy Note 10+), iPhone10,1 (for iOS, hardware identifier e.g. iPhone10,1 -> iPhone 8)) */
    deviceModel?: string;
    /** OS Version of the connecting device (e.g. 9.0, 11.0.1) */
    deviceOSVersion?: string;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    passwordTimeStamp?: moment.Moment | undefined;
    oTPTimeStamp?: moment.Moment | undefined;
    /** Points amount (if any) */
    pointsTRY?: number | undefined;
}

/** Type of the credit card */
export enum CreditCardTypeEnum {
    Unknown = "Unknown",
    Visa = "Visa",
    MasterCard = "MasterCard",
    Discover = "Discover",
    Amex = "Amex",
    Switch = "Switch",
    Solo = "Solo",
    Troy = "Troy",
}

/** Card information for creation */
export class CardCreateDTO implements ICardCreateDTO {
    /** Alias given to the stored card by the member */
    alias!: string;
    /** The full name of the card holder as printed on the card */
    cardHolder!: string;
    /** Credit card PAN */
    pAN!: string;
    /** Credit card expiry month */
    expiryMonth!: string;
    /** Credit card expiry year */
    expiryYear!: string;
    /** Credit card CVC */
    cVC!: string;
    useThreeDS?: boolean | undefined;

    constructor(data?: ICardCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["Alias"];
            this.cardHolder = _data["CardHolder"];
            this.pAN = _data["PAN"];
            this.expiryMonth = _data["ExpiryMonth"];
            this.expiryYear = _data["ExpiryYear"];
            this.cVC = _data["CVC"];
            this.useThreeDS = _data["UseThreeDS"];
        }
    }

    static fromJS(data: any): CardCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CardCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alias"] = this.alias;
        data["CardHolder"] = this.cardHolder;
        data["PAN"] = this.pAN;
        data["ExpiryMonth"] = this.expiryMonth;
        data["ExpiryYear"] = this.expiryYear;
        data["CVC"] = this.cVC;
        data["UseThreeDS"] = this.useThreeDS;
        return data; 
    }
}

/** Card information for creation */
export interface ICardCreateDTO {
    /** Alias given to the stored card by the member */
    alias: string;
    /** The full name of the card holder as printed on the card */
    cardHolder: string;
    /** Credit card PAN */
    pAN: string;
    /** Credit card expiry month */
    expiryMonth: string;
    /** Credit card expiry year */
    expiryYear: string;
    /** Credit card CVC */
    cVC: string;
    useThreeDS?: boolean | undefined;
}

/** Card information for retrieval */
export class CardDTO implements ICardDTO {
    /** Alias given to the stored card by the member */
    alias?: string;
    cardID?: string;
    /** The full name of the card holder as printed on the card */
    cardHolder?: string;
    /** Credit card PAN */
    pAN?: string;
    /** Card issuer bank */
    bankName?: string;
    /** Card family name */
    familyName?: string;
    /** True if the card is a business card */
    isBusinessCard?: boolean | undefined;
    /** True if the user should enter CVC */
    isCVCRequired?: boolean | undefined;
    creditCardType?: CreditCardTypeEnum | undefined;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string;
    kPayTxnID?: string;

    constructor(data?: ICardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["Alias"];
            this.cardID = _data["CardID"];
            this.cardHolder = _data["CardHolder"];
            this.pAN = _data["PAN"];
            this.bankName = _data["BankName"];
            this.familyName = _data["FamilyName"];
            this.isBusinessCard = _data["IsBusinessCard"];
            this.isCVCRequired = _data["IsCVCRequired"];
            this.creditCardType = _data["CreditCardType"];
            this.creationTimeStamp = _data["CreationTimeStamp"] ? moment(_data["CreationTimeStamp"].toString()) : <any>undefined;
            this.modificationTimeStamp = _data["ModificationTimeStamp"] ? moment(_data["ModificationTimeStamp"].toString()) : <any>undefined;
            this.isThreeDS = _data["IsThreeDS"];
            this.threeDS_HTML = _data["ThreeDS_HTML"];
            this.kPayTxnID = _data["KPayTxnID"];
        }
    }

    static fromJS(data: any): CardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alias"] = this.alias;
        data["CardID"] = this.cardID;
        data["CardHolder"] = this.cardHolder;
        data["PAN"] = this.pAN;
        data["BankName"] = this.bankName;
        data["FamilyName"] = this.familyName;
        data["IsBusinessCard"] = this.isBusinessCard;
        data["IsCVCRequired"] = this.isCVCRequired;
        data["CreditCardType"] = this.creditCardType;
        data["CreationTimeStamp"] = this.creationTimeStamp ? this.creationTimeStamp.toISOString() : <any>undefined;
        data["ModificationTimeStamp"] = this.modificationTimeStamp ? this.modificationTimeStamp.toISOString() : <any>undefined;
        data["IsThreeDS"] = this.isThreeDS;
        data["ThreeDS_HTML"] = this.threeDS_HTML;
        data["KPayTxnID"] = this.kPayTxnID;
        return data; 
    }
}

/** Card information for retrieval */
export interface ICardDTO {
    /** Alias given to the stored card by the member */
    alias?: string;
    cardID?: string;
    /** The full name of the card holder as printed on the card */
    cardHolder?: string;
    /** Credit card PAN */
    pAN?: string;
    /** Card issuer bank */
    bankName?: string;
    /** Card family name */
    familyName?: string;
    /** True if the card is a business card */
    isBusinessCard?: boolean | undefined;
    /** True if the user should enter CVC */
    isCVCRequired?: boolean | undefined;
    creditCardType?: CreditCardTypeEnum | undefined;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string;
    kPayTxnID?: string;
}

/** Application related information */
export class ApplicationInfoDTO implements IApplicationInfoDTO {
    /** General parameters in JSON format */
    parameters?: string;
    /** Mersis No of the application owner company */
    mersisNo?: string;
    defaultCheckoutCode?: string;
    visuals!: string[];

    constructor(data?: IApplicationInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.visuals = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameters = _data["Parameters"];
            this.mersisNo = _data["MersisNo"];
            this.defaultCheckoutCode = _data["DefaultCheckoutCode"];
            if (Array.isArray(_data["Visuals"])) {
                this.visuals = [] as any;
                for (let item of _data["Visuals"])
                    this.visuals!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Parameters"] = this.parameters;
        data["MersisNo"] = this.mersisNo;
        data["DefaultCheckoutCode"] = this.defaultCheckoutCode;
        if (Array.isArray(this.visuals)) {
            data["Visuals"] = [];
            for (let item of this.visuals)
                data["Visuals"].push(item);
        }
        return data; 
    }
}

/** Application related information */
export interface IApplicationInfoDTO {
    /** General parameters in JSON format */
    parameters?: string;
    /** Mersis No of the application owner company */
    mersisNo?: string;
    defaultCheckoutCode?: string;
    visuals: string[];
}

/** Application visual */
export class ApplicationVisualDTO implements IApplicationVisualDTO {
    code?: string;
    dataVersion?: number | undefined;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IApplicationVisualDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.dataVersion = _data["DataVersion"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): ApplicationVisualDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVisualDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["DataVersion"] = this.dataVersion;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** Application visual */
export interface IApplicationVisualDTO {
    code?: string;
    dataVersion?: number | undefined;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Type of the complaint */
export enum ComplaintTypeEnum {
    Complaint = "Complaint",
    Suggestion = "Suggestion",
    PaymentProblem = "PaymentProblem",
    SellerProblem = "SellerProblem",
    RefundRequest = "RefundRequest",
}

/** Complaint information */
export class ComplaintDTO implements IComplaintDTO {
    memberID!: string;
    complaintType!: ComplaintTypeEnum;
    /** Text of the complaint */
    complaintText!: string;

    constructor(data?: IComplaintDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberID = _data["MemberID"];
            this.complaintType = _data["ComplaintType"];
            this.complaintText = _data["ComplaintText"];
        }
    }

    static fromJS(data: any): ComplaintDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ComplaintDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberID"] = this.memberID;
        data["ComplaintType"] = this.complaintType;
        data["ComplaintText"] = this.complaintText;
        return data; 
    }
}

/** Complaint information */
export interface IComplaintDTO {
    memberID: string;
    complaintType: ComplaintTypeEnum;
    /** Text of the complaint */
    complaintText: string;
}

/** Member information for retrieval and update */
export class PaginationInfo implements IPaginationInfo {
    /** Current page number */
    pageNo!: number;
    /** Maximum number of items per page */
    pageSize!: number;
    /** Total number of pages */
    totalPages!: number;
    /** Total number of items */
    totalItems!: number;

    constructor(data?: IPaginationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNo = _data["PageNo"];
            this.pageSize = _data["PageSize"];
            this.totalPages = _data["TotalPages"];
            this.totalItems = _data["TotalItems"];
        }
    }

    static fromJS(data: any): PaginationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PageNo"] = this.pageNo;
        data["PageSize"] = this.pageSize;
        data["TotalPages"] = this.totalPages;
        data["TotalItems"] = this.totalItems;
        return data; 
    }
}

/** Member information for retrieval and update */
export interface IPaginationInfo {
    /** Current page number */
    pageNo: number;
    /** Maximum number of items per page */
    pageSize: number;
    /** Total number of pages */
    totalPages: number;
    /** Total number of items */
    totalItems: number;
}

/** Type of the payment */
export enum PaymentTypeEnum {
    Request = "Request",
    DynamicQRBEX = "DynamicQRBEX",
    FixedQRBEX = "FixedQRBEX",
    CreditCard = "CreditCard",
    Cash = "Cash",
    ECRCash = "ECRCash",
    ECRCreditCard = "ECRCreditCard",
    ECRBEX = "ECRBEX",
    ECROther = "ECROther",
    StoredCreditCard = "StoredCreditCard",
    MasterPass = "MasterPass",
}

/** Default status is 'Started' after the transaction is created. Await until a status other than 'None' or 'Started' is returned. - None : Initial request state - Started : Transaction is created (Created) - Paid : Transaction is processed successfully (Success) - Denied : Payment is denied (Failure) - Orphaned : Transaction is orphaned (Failure) - Timeout : Transaction is timed out (Failure) - Cancelled : Transaction is cancelled by the merchant (Cancellation) - AutoCancelled : Transaction is cancelled by the system (Cancellation) - Refunded : Payment amount is refunded to the customer (Refunded) - Closed : Transaction is processed successfully (Success) */
export enum PaymentStatusEnum {
    None = "None",
    Started = "Started",
    Paid = "Paid",
    Denied = "Denied",
    Orphaned = "Orphaned",
    Timeout = "Timeout",
    Cancelled = "Cancelled",
    AutoCancelled = "AutoCancelled",
    Refunded = "Refunded",
    Closed = "Closed",
}

/** Payment summary information */
export class PaymentSummaryDTO implements IPaymentSummaryDTO {
    kPayTxnID?: string;
    paymentType?: PaymentTypeEnum | undefined;
    paymentStatus?: PaymentStatusEnum | undefined;
    requestTimeStamp?: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    /** The requested payment amount */
    transactionAmountTRY?: number | undefined;
    /** The amount paid by the customer */
    paymentAmountTRY?: number | undefined;
    /** Discount amount (if any) (TransactionAmountTRY - PaymentAmountTRY) */
    discountAmountTRY?: number | undefined;
    /** Campaign name causing the discount (if any) */
    campaignInfo?: string;
    /** Institution name */
    institutionName?: string;
    /** Institution branch name */
    branchName?: string;
    /** Description of the error (if any) */
    errorDescription?: string;
    /** Description of the payment result if unsuccessful */
    paymentResult?: string;

    constructor(data?: IPaymentSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kPayTxnID = _data["KPayTxnID"];
            this.paymentType = _data["PaymentType"];
            this.paymentStatus = _data["PaymentStatus"];
            this.requestTimeStamp = _data["RequestTimeStamp"] ? moment(_data["RequestTimeStamp"].toString()) : <any>undefined;
            this.paymentTimeStamp = _data["PaymentTimeStamp"] ? moment(_data["PaymentTimeStamp"].toString()) : <any>undefined;
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.paymentAmountTRY = _data["PaymentAmountTRY"];
            this.discountAmountTRY = _data["DiscountAmountTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.institutionName = _data["InstitutionName"];
            this.branchName = _data["BranchName"];
            this.errorDescription = _data["ErrorDescription"];
            this.paymentResult = _data["PaymentResult"];
        }
    }

    static fromJS(data: any): PaymentSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["KPayTxnID"] = this.kPayTxnID;
        data["PaymentType"] = this.paymentType;
        data["PaymentStatus"] = this.paymentStatus;
        data["RequestTimeStamp"] = this.requestTimeStamp ? this.requestTimeStamp.toISOString() : <any>undefined;
        data["PaymentTimeStamp"] = this.paymentTimeStamp ? this.paymentTimeStamp.toISOString() : <any>undefined;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["PaymentAmountTRY"] = this.paymentAmountTRY;
        data["DiscountAmountTRY"] = this.discountAmountTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["InstitutionName"] = this.institutionName;
        data["BranchName"] = this.branchName;
        data["ErrorDescription"] = this.errorDescription;
        data["PaymentResult"] = this.paymentResult;
        return data; 
    }
}

/** Payment summary information */
export interface IPaymentSummaryDTO {
    kPayTxnID?: string;
    paymentType?: PaymentTypeEnum | undefined;
    paymentStatus?: PaymentStatusEnum | undefined;
    requestTimeStamp?: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    /** The requested payment amount */
    transactionAmountTRY?: number | undefined;
    /** The amount paid by the customer */
    paymentAmountTRY?: number | undefined;
    /** Discount amount (if any) (TransactionAmountTRY - PaymentAmountTRY) */
    discountAmountTRY?: number | undefined;
    /** Campaign name causing the discount (if any) */
    campaignInfo?: string;
    /** Institution name */
    institutionName?: string;
    /** Institution branch name */
    branchName?: string;
    /** Description of the error (if any) */
    errorDescription?: string;
    /** Description of the payment result if unsuccessful */
    paymentResult?: string;
}

/** Paginated payment result set */
export class PaginatedPaymentSummaryDTO implements IPaginatedPaymentSummaryDTO {
    paginationInfo!: PaginationInfo;
    /** Zero or more payment information */
    resultSet!: PaymentSummaryDTO[];

    constructor(data?: IPaginatedPaymentSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paginationInfo = new PaginationInfo();
            this.resultSet = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paginationInfo = _data["PaginationInfo"] ? PaginationInfo.fromJS(_data["PaginationInfo"]) : new PaginationInfo();
            if (Array.isArray(_data["ResultSet"])) {
                this.resultSet = [] as any;
                for (let item of _data["ResultSet"])
                    this.resultSet!.push(PaymentSummaryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedPaymentSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedPaymentSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaginationInfo"] = this.paginationInfo ? this.paginationInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.resultSet)) {
            data["ResultSet"] = [];
            for (let item of this.resultSet)
                data["ResultSet"].push(item.toJSON());
        }
        return data; 
    }
}

/** Paginated payment result set */
export interface IPaginatedPaymentSummaryDTO {
    paginationInfo: PaginationInfo;
    /** Zero or more payment information */
    resultSet: PaymentSummaryDTO[];
}

/** Full payment info */
export class PaymentDTO extends PaymentSummaryDTO implements IPaymentDTO {
    /** The unique transaction ID the merchant system has assigned to this payment */
    merchantTransactionID?: string;
    /** The receipt number the merchant system has assigned to this payment */
    merchantReceiptNo?: string;
    /** Requesting institution code */
    institutionCode?: string;
    /** Requesting institution ERP code */
    institutionERPCode?: string;
    /** Institution branch code */
    branchCode?: string;
    /** Institution branch ERP code */
    branchERPCode?: string;
    /** Checkout point name */
    checkoutPointName?: string;
    /** Checkout point code */
    checkoutPointCode?: string;
    /** Campaign code causing the discount (if any) */
    campaignCode?: string;
    /** An error occurred during the processing */
    hasError?: boolean | undefined;
    /** Is this a test payment (currently not operational) */
    isTestPayment?: boolean | undefined;
    /** Note/description for the payment */
    paymentNote?: string;

    constructor(data?: IPaymentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.merchantTransactionID = _data["MerchantTransactionID"];
            this.merchantReceiptNo = _data["MerchantReceiptNo"];
            this.institutionCode = _data["InstitutionCode"];
            this.institutionERPCode = _data["InstitutionERPCode"];
            this.branchCode = _data["BranchCode"];
            this.branchERPCode = _data["BranchERPCode"];
            this.checkoutPointName = _data["CheckoutPointName"];
            this.checkoutPointCode = _data["CheckoutPointCode"];
            this.campaignCode = _data["CampaignCode"];
            this.hasError = _data["HasError"];
            this.isTestPayment = _data["IsTestPayment"];
            this.paymentNote = _data["PaymentNote"];
        }
    }

    static fromJS(data: any): PaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MerchantTransactionID"] = this.merchantTransactionID;
        data["MerchantReceiptNo"] = this.merchantReceiptNo;
        data["InstitutionCode"] = this.institutionCode;
        data["InstitutionERPCode"] = this.institutionERPCode;
        data["BranchCode"] = this.branchCode;
        data["BranchERPCode"] = this.branchERPCode;
        data["CheckoutPointName"] = this.checkoutPointName;
        data["CheckoutPointCode"] = this.checkoutPointCode;
        data["CampaignCode"] = this.campaignCode;
        data["HasError"] = this.hasError;
        data["IsTestPayment"] = this.isTestPayment;
        data["PaymentNote"] = this.paymentNote;
        super.toJSON(data);
        return data; 
    }
}

/** Full payment info */
export interface IPaymentDTO extends IPaymentSummaryDTO {
    /** The unique transaction ID the merchant system has assigned to this payment */
    merchantTransactionID?: string;
    /** The receipt number the merchant system has assigned to this payment */
    merchantReceiptNo?: string;
    /** Requesting institution code */
    institutionCode?: string;
    /** Requesting institution ERP code */
    institutionERPCode?: string;
    /** Institution branch code */
    branchCode?: string;
    /** Institution branch ERP code */
    branchERPCode?: string;
    /** Checkout point name */
    checkoutPointName?: string;
    /** Checkout point code */
    checkoutPointCode?: string;
    /** Campaign code causing the discount (if any) */
    campaignCode?: string;
    /** An error occurred during the processing */
    hasError?: boolean | undefined;
    /** Is this a test payment (currently not operational) */
    isTestPayment?: boolean | undefined;
    /** Note/description for the payment */
    paymentNote?: string;
}

/** Summary establishment info */
export class EstablishmentSummaryDTO implements IEstablishmentSummaryDTO {
    /** Unique integer ID for this establishment */
    rID?: number;
    name?: string;
    category?: string;
    workingHours?: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    phoneNo?: string;
    locationDescription?: string;
    province?: string;
    district?: string;

    constructor(data?: IEstablishmentSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.category = _data["Category"];
            this.workingHours = _data["WorkingHours"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.phoneNo = _data["PhoneNo"];
            this.locationDescription = _data["LocationDescription"];
            this.province = _data["Province"];
            this.district = _data["District"];
        }
    }

    static fromJS(data: any): EstablishmentSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EstablishmentSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["Category"] = this.category;
        data["WorkingHours"] = this.workingHours;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["PhoneNo"] = this.phoneNo;
        data["LocationDescription"] = this.locationDescription;
        data["Province"] = this.province;
        data["District"] = this.district;
        return data; 
    }
}

/** Summary establishment info */
export interface IEstablishmentSummaryDTO {
    /** Unique integer ID for this establishment */
    rID?: number;
    name?: string;
    category?: string;
    workingHours?: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    phoneNo?: string;
    locationDescription?: string;
    province?: string;
    district?: string;
}

/** Type of the establishment */
export enum EstablishmentTypeEnum {
    Branch = "Branch",
    Franchise = "Franchise",
}

/** Full establishment info */
export class EstablishmentDTO extends EstablishmentSummaryDTO implements IEstablishmentDTO {
    checkoutCode?: string;
    establishmentType?: EstablishmentTypeEnum | undefined;
    webSite?: string;
    instagram?: string;
    facebook?: string;
    twitter?: string;
    address?: string;
    postalCode?: string;
    description?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IEstablishmentDTO) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.checkoutCode = _data["CheckoutCode"];
            this.establishmentType = _data["EstablishmentType"];
            this.webSite = _data["WebSite"];
            this.instagram = _data["Instagram"];
            this.facebook = _data["Facebook"];
            this.twitter = _data["Twitter"];
            this.address = _data["Address"];
            this.postalCode = _data["PostalCode"];
            this.description = _data["Description"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): EstablishmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EstablishmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CheckoutCode"] = this.checkoutCode;
        data["EstablishmentType"] = this.establishmentType;
        data["WebSite"] = this.webSite;
        data["Instagram"] = this.instagram;
        data["Facebook"] = this.facebook;
        data["Twitter"] = this.twitter;
        data["Address"] = this.address;
        data["PostalCode"] = this.postalCode;
        data["Description"] = this.description;
        data["Visual"] = this.visual;
        super.toJSON(data);
        return data; 
    }
}

/** Full establishment info */
export interface IEstablishmentDTO extends IEstablishmentSummaryDTO {
    checkoutCode?: string;
    establishmentType?: EstablishmentTypeEnum | undefined;
    webSite?: string;
    instagram?: string;
    facebook?: string;
    twitter?: string;
    address?: string;
    postalCode?: string;
    description?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** News info */
export class NewsDTO implements INewsDTO {
    /** Unique integer ID for this news item */
    rID?: number;
    header?: string;
    detail?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: INewsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.header = _data["Header"];
            this.detail = _data["Detail"];
            this.validFrom = _data["ValidFrom"] ? moment(_data["ValidFrom"].toString()) : <any>undefined;
            this.validTo = _data["ValidTo"] ? moment(_data["ValidTo"].toString()) : <any>undefined;
            this.webSite = _data["WebSite"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): NewsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NewsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Header"] = this.header;
        data["Detail"] = this.detail;
        data["ValidFrom"] = this.validFrom ? this.validFrom.format('YYYY-MM-DD') : <any>undefined;
        data["ValidTo"] = this.validTo ? this.validTo.format('YYYY-MM-DD') : <any>undefined;
        data["WebSite"] = this.webSite;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** News info */
export interface INewsDTO {
    /** Unique integer ID for this news item */
    rID?: number;
    header?: string;
    detail?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Event info */
export class EventDTO implements IEventDTO {
    /** Unique integer ID for this event */
    rID?: number;
    header?: string;
    detail?: string;
    eventTimeStamp?: moment.Moment | undefined;
    /** Unique integer ID for the establishment */
    establishmentRID?: number;
    establishmentName?: string;
    webSite?: string;
    province?: string;
    /** Is this event enabled for mobile sale */
    isSaleEnabled?: boolean;
    /** Event ticket price */
    priceIncVATTRY?: number;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.header = _data["Header"];
            this.detail = _data["Detail"];
            this.eventTimeStamp = _data["EventTimeStamp"] ? moment(_data["EventTimeStamp"].toString()) : <any>undefined;
            this.establishmentRID = _data["EstablishmentRID"];
            this.establishmentName = _data["EstablishmentName"];
            this.webSite = _data["WebSite"];
            this.province = _data["Province"];
            this.isSaleEnabled = _data["IsSaleEnabled"];
            this.priceIncVATTRY = _data["PriceIncVATTRY"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): EventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Header"] = this.header;
        data["Detail"] = this.detail;
        data["EventTimeStamp"] = this.eventTimeStamp ? this.eventTimeStamp.toISOString() : <any>undefined;
        data["EstablishmentRID"] = this.establishmentRID;
        data["EstablishmentName"] = this.establishmentName;
        data["WebSite"] = this.webSite;
        data["Province"] = this.province;
        data["IsSaleEnabled"] = this.isSaleEnabled;
        data["PriceIncVATTRY"] = this.priceIncVATTRY;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** Event info */
export interface IEventDTO {
    /** Unique integer ID for this event */
    rID?: number;
    header?: string;
    detail?: string;
    eventTimeStamp?: moment.Moment | undefined;
    /** Unique integer ID for the establishment */
    establishmentRID?: number;
    establishmentName?: string;
    webSite?: string;
    province?: string;
    /** Is this event enabled for mobile sale */
    isSaleEnabled?: boolean;
    /** Event ticket price */
    priceIncVATTRY?: number;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Paginated event result set */
export class PaginatedEventDTO implements IPaginatedEventDTO {
    paginationInfo!: PaginationInfo;
    /** Zero or more event information */
    resultSet!: EventDTO[];

    constructor(data?: IPaginatedEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paginationInfo = new PaginationInfo();
            this.resultSet = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paginationInfo = _data["PaginationInfo"] ? PaginationInfo.fromJS(_data["PaginationInfo"]) : new PaginationInfo();
            if (Array.isArray(_data["ResultSet"])) {
                this.resultSet = [] as any;
                for (let item of _data["ResultSet"])
                    this.resultSet!.push(EventDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaginationInfo"] = this.paginationInfo ? this.paginationInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.resultSet)) {
            data["ResultSet"] = [];
            for (let item of this.resultSet)
                data["ResultSet"].push(item.toJSON());
        }
        return data; 
    }
}

/** Paginated event result set */
export interface IPaginatedEventDTO {
    paginationInfo: PaginationInfo;
    /** Zero or more event information */
    resultSet: EventDTO[];
}

/** Establishment which participates in a campaign */
export class CampaignEstablishmentDTO implements ICampaignEstablishmentDTO {
    /** Unique integer ID for this establishment */
    rID?: number;
    /** Establishment name */
    name?: string;

    constructor(data?: ICampaignEstablishmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): CampaignEstablishmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignEstablishmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        return data; 
    }
}

/** Establishment which participates in a campaign */
export interface ICampaignEstablishmentDTO {
    /** Unique integer ID for this establishment */
    rID?: number;
    /** Establishment name */
    name?: string;
}

/** Campaign info */
export class CampaignDTO implements ICampaignDTO {
    /** Unique integer ID for this campaign */
    rID?: number;
    header?: string;
    detail?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
    /** The establishments which participate in this campaign */
    participatingEstablishments?: CampaignEstablishmentDTO[];

    constructor(data?: ICampaignDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.header = _data["Header"];
            this.detail = _data["Detail"];
            this.validFrom = _data["ValidFrom"] ? moment(_data["ValidFrom"].toString()) : <any>undefined;
            this.validTo = _data["ValidTo"] ? moment(_data["ValidTo"].toString()) : <any>undefined;
            this.webSite = _data["WebSite"];
            this.visual = _data["Visual"];
            if (Array.isArray(_data["ParticipatingEstablishments"])) {
                this.participatingEstablishments = [] as any;
                for (let item of _data["ParticipatingEstablishments"])
                    this.participatingEstablishments!.push(CampaignEstablishmentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CampaignDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CampaignDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Header"] = this.header;
        data["Detail"] = this.detail;
        data["ValidFrom"] = this.validFrom ? this.validFrom.format('YYYY-MM-DD') : <any>undefined;
        data["ValidTo"] = this.validTo ? this.validTo.format('YYYY-MM-DD') : <any>undefined;
        data["WebSite"] = this.webSite;
        data["Visual"] = this.visual;
        if (Array.isArray(this.participatingEstablishments)) {
            data["ParticipatingEstablishments"] = [];
            for (let item of this.participatingEstablishments)
                data["ParticipatingEstablishments"].push(item.toJSON());
        }
        return data; 
    }
}

/** Campaign info */
export interface ICampaignDTO {
    /** Unique integer ID for this campaign */
    rID?: number;
    header?: string;
    detail?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
    /** The establishments which participate in this campaign */
    participatingEstablishments?: CampaignEstablishmentDTO[];
}

/** Advertisement info */
export class AdvertisementDTO implements IAdvertisementDTO {
    /** Unique integer ID for this Advertisement */
    rID?: number;
    header?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    /** Duration in seconds for advertisement display */
    duration?: number;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IAdvertisementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.header = _data["Header"];
            this.validFrom = _data["ValidFrom"] ? moment(_data["ValidFrom"].toString()) : <any>undefined;
            this.validTo = _data["ValidTo"] ? moment(_data["ValidTo"].toString()) : <any>undefined;
            this.duration = _data["Duration"];
            this.webSite = _data["WebSite"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): AdvertisementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Header"] = this.header;
        data["ValidFrom"] = this.validFrom ? this.validFrom.format('YYYY-MM-DD') : <any>undefined;
        data["ValidTo"] = this.validTo ? this.validTo.format('YYYY-MM-DD') : <any>undefined;
        data["Duration"] = this.duration;
        data["WebSite"] = this.webSite;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** Advertisement info */
export interface IAdvertisementDTO {
    /** Unique integer ID for this Advertisement */
    rID?: number;
    header?: string;
    /** Date in ISO 8601 full date format */
    validFrom?: moment.Moment | undefined;
    /** Date in ISO 8601 full date format */
    validTo?: moment.Moment | undefined;
    /** Duration in seconds for advertisement display */
    duration?: number;
    webSite?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** QR Payment Mode ('None' indicates that payments are disabled at the checkout) */
export enum QRPaymentModeEnum {
    None = "None",
    FixedQR = "FixedQR",
    FixedQRAndAmount = "FixedQRAndAmount",
    FixedQRAndFixedAmount = "FixedQRAndFixedAmount",
    DynamicQR = "DynamicQR",
    DynamicQRAndAmount = "DynamicQRAndAmount",
    DynamicQRAndFixedAmount = "DynamicQRAndFixedAmount",
    MetropolQR = "MetropolQR",
}

/** POS Terminal type */
export enum POSTerminalTypeEnum {
    KPayPOS = "KPayPOS",
    KPayPOSWorkinton = "KPayPOSWorkinton",
    KPayGO = "KPayGO",
    KPayWeb = "KPayWeb",
    MerchantPOS = "MerchantPOS",
    MerchantApp = "MerchantApp",
    MerchantWeb = "MerchantWeb",
    MetropolPOS = "MetropolPOS",
}

/** Contains information about a checkout */
export class CheckoutDTO implements ICheckoutDTO {
    /** Institution code */
    institutionCode?: string;
    /** Institution ERP code */
    institutionERPCode?: string;
    /** Institution name */
    institutionName?: string;
    /** Branch code */
    branchCode?: string;
    /** Branch ERP code */
    branchERPCode?: string;
    /** Branch name */
    branchName?: string;
    /** Checkout point code */
    checkoutPointCode?: string;
    /** Checkout point name */
    checkoutPointName?: string;
    /** Unique integer ID for the establishment */
    establishmentRID?: number;
    establishmentName?: string;
    qRPaymentMode?: QRPaymentModeEnum;
    pOSTerminalType?: POSTerminalTypeEnum;
    /** Multiple payment requests can be done simultaneously */
    isMultiplePaymentsEnabled?: boolean;

    constructor(data?: ICheckoutDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.institutionCode = _data["InstitutionCode"];
            this.institutionERPCode = _data["InstitutionERPCode"];
            this.institutionName = _data["InstitutionName"];
            this.branchCode = _data["BranchCode"];
            this.branchERPCode = _data["BranchERPCode"];
            this.branchName = _data["BranchName"];
            this.checkoutPointCode = _data["CheckoutPointCode"];
            this.checkoutPointName = _data["CheckoutPointName"];
            this.establishmentRID = _data["EstablishmentRID"];
            this.establishmentName = _data["EstablishmentName"];
            this.qRPaymentMode = _data["QRPaymentMode"];
            this.pOSTerminalType = _data["POSTerminalType"];
            this.isMultiplePaymentsEnabled = _data["IsMultiplePaymentsEnabled"];
        }
    }

    static fromJS(data: any): CheckoutDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["InstitutionCode"] = this.institutionCode;
        data["InstitutionERPCode"] = this.institutionERPCode;
        data["InstitutionName"] = this.institutionName;
        data["BranchCode"] = this.branchCode;
        data["BranchERPCode"] = this.branchERPCode;
        data["BranchName"] = this.branchName;
        data["CheckoutPointCode"] = this.checkoutPointCode;
        data["CheckoutPointName"] = this.checkoutPointName;
        data["EstablishmentRID"] = this.establishmentRID;
        data["EstablishmentName"] = this.establishmentName;
        data["QRPaymentMode"] = this.qRPaymentMode;
        data["POSTerminalType"] = this.pOSTerminalType;
        data["IsMultiplePaymentsEnabled"] = this.isMultiplePaymentsEnabled;
        return data; 
    }
}

/** Contains information about a checkout */
export interface ICheckoutDTO {
    /** Institution code */
    institutionCode?: string;
    /** Institution ERP code */
    institutionERPCode?: string;
    /** Institution name */
    institutionName?: string;
    /** Branch code */
    branchCode?: string;
    /** Branch ERP code */
    branchERPCode?: string;
    /** Branch name */
    branchName?: string;
    /** Checkout point code */
    checkoutPointCode?: string;
    /** Checkout point name */
    checkoutPointName?: string;
    /** Unique integer ID for the establishment */
    establishmentRID?: number;
    establishmentName?: string;
    qRPaymentMode?: QRPaymentModeEnum;
    pOSTerminalType?: POSTerminalTypeEnum;
    /** Multiple payment requests can be done simultaneously */
    isMultiplePaymentsEnabled?: boolean;
}

/** Province info */
export class ProvinceDTO implements IProvinceDTO {
    /** Unique integer ID for this Province */
    rID!: number;
    /** Province name */
    name!: string;

    constructor(data?: IProvinceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): ProvinceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        return data; 
    }
}

/** Province info */
export interface IProvinceDTO {
    /** Unique integer ID for this Province */
    rID: number;
    /** Province name */
    name: string;
}

/** District info */
export class DistrictDTO implements IDistrictDTO {
    /** Unique integer ID for this District */
    rID!: number;
    /** District name */
    name!: string;

    constructor(data?: IDistrictDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): DistrictDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        return data; 
    }
}

/** District info */
export interface IDistrictDTO {
    /** Unique integer ID for this District */
    rID: number;
    /** District name */
    name: string;
}

/** ProductCategory info */
export class ProductCategoryDTO implements IProductCategoryDTO {
    /** Unique integer ID for this ProductCategory */
    rID!: number;
    name!: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IProductCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): ProductCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** ProductCategory info */
export interface IProductCategoryDTO {
    /** Unique integer ID for this ProductCategory */
    rID: number;
    name: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Product info */
export class ProductDTO implements IProductDTO {
    /** Unique integer ID for this Product */
    rID!: number;
    name!: string;
    /** RID of ProductCategory this product belongs to */
    productCategoryRID!: number;
    /** Name of ProductCategory this product belongs to */
    productCategoryName!: string;
    /** Product price including VAT */
    priceIncVATTRY!: number;
    description?: string | undefined;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IProductDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.productCategoryRID = _data["ProductCategoryRID"];
            this.productCategoryName = _data["ProductCategoryName"];
            this.priceIncVATTRY = _data["PriceIncVATTRY"];
            this.description = _data["Description"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): ProductDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["ProductCategoryRID"] = this.productCategoryRID;
        data["ProductCategoryName"] = this.productCategoryName;
        data["PriceIncVATTRY"] = this.priceIncVATTRY;
        data["Description"] = this.description;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** Product info */
export interface IProductDTO {
    /** Unique integer ID for this Product */
    rID: number;
    name: string;
    /** RID of ProductCategory this product belongs to */
    productCategoryRID: number;
    /** Name of ProductCategory this product belongs to */
    productCategoryName: string;
    /** Product price including VAT */
    priceIncVATTRY: number;
    description?: string | undefined;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Branch info */
export class BranchDTO implements IBranchDTO {
    /** Unique integer ID for this branch */
    rID?: number;
    name?: string;
    officalName?: string;
    phoneNo?: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    address?: string;
    provinceRID?: number;
    province?: string;
    districtRID?: number;
    district?: string;
    businessSector?: string;
    businessSubSector?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;

    constructor(data?: IBranchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.officalName = _data["OfficalName"];
            this.phoneNo = _data["PhoneNo"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.address = _data["Address"];
            this.provinceRID = _data["ProvinceRID"];
            this.province = _data["Province"];
            this.districtRID = _data["DistrictRID"];
            this.district = _data["District"];
            this.businessSector = _data["BusinessSector"];
            this.businessSubSector = _data["BusinessSubSector"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): BranchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["OfficalName"] = this.officalName;
        data["PhoneNo"] = this.phoneNo;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["Address"] = this.address;
        data["ProvinceRID"] = this.provinceRID;
        data["Province"] = this.province;
        data["DistrictRID"] = this.districtRID;
        data["District"] = this.district;
        data["BusinessSector"] = this.businessSector;
        data["BusinessSubSector"] = this.businessSubSector;
        data["Visual"] = this.visual;
        return data; 
    }
}

/** Branch info */
export interface IBranchDTO {
    /** Unique integer ID for this branch */
    rID?: number;
    name?: string;
    officalName?: string;
    phoneNo?: string;
    latitude?: number | undefined;
    longitude?: number | undefined;
    address?: string;
    provinceRID?: number;
    province?: string;
    districtRID?: number;
    district?: string;
    businessSector?: string;
    businessSubSector?: string;
    /** Base64 encoded image e.g. 'data:image/png;base64,IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string | undefined;
}

/** Paginated branch result set */
export class PaginatedBranchListDTO implements IPaginatedBranchListDTO {
    paginationInfo!: PaginationInfo;
    /** Zero or more branch information */
    branchList!: BranchDTO[];

    constructor(data?: IPaginatedBranchListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paginationInfo = new PaginationInfo();
            this.branchList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paginationInfo = _data["PaginationInfo"] ? PaginationInfo.fromJS(_data["PaginationInfo"]) : new PaginationInfo();
            if (Array.isArray(_data["BranchList"])) {
                this.branchList = [] as any;
                for (let item of _data["BranchList"])
                    this.branchList!.push(BranchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedBranchListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedBranchListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaginationInfo"] = this.paginationInfo ? this.paginationInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.branchList)) {
            data["BranchList"] = [];
            for (let item of this.branchList)
                data["BranchList"].push(item.toJSON());
        }
        return data; 
    }
}

/** Paginated branch result set */
export interface IPaginatedBranchListDTO {
    paginationInfo: PaginationInfo;
    /** Zero or more branch information */
    branchList: BranchDTO[];
}

/** Result of the API operation */
export class APIResultDTO implements IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code!: number;
    /** A description of the result code */
    message!: string;
    /** Error list (if any) */
    errors?: string[];

    constructor(data?: IAPIResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): APIResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new APIResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item);
        }
        return data; 
    }
}

/** Result of the API operation */
export interface IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code: number;
    /** A description of the result code */
    message: string;
    /** Error list (if any) */
    errors?: string[];
}

/** Ping result */
export class PingResultDTO implements IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime!: moment.Moment;

    constructor(data?: IPingResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverDateTime = _data["ServerDateTime"] ? moment(_data["ServerDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PingResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PingResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ServerDateTime"] = this.serverDateTime ? this.serverDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** Ping result */
export interface IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime: moment.Moment;
}

export enum Language {
    TR = "TR",
    EN = "EN",
}

export enum VisualSize {
    Normal = "Normal",
    Small = "Small",
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = getFileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
export function getFileReader(): FileReader {
	const fileReader = new FileReader();
	const zoneOriginalInstance = (fileReader as any)["__zone_symbol__originalInstance"];
	return zoneOriginalInstance || fileReader;
}